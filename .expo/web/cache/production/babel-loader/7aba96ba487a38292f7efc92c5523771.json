{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */exports.GREATEST_LOWER_BOUND=1;exports.LEAST_UPPER_BOUND=2;/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */function recursiveSearch(aLow,aHigh,aNeedle,aHaystack,aCompare,aBias){// This function terminates when one of the following is true:\n//\n//   1. We find the exact element we are looking for.\n//\n//   2. We did not find the exact element, but we can return the index of\n//      the next-closest element.\n//\n//   3. We did not find the exact element, and there is no next-closest\n//      element than the one we are searching for, so we return -1.\nvar mid=Math.floor((aHigh-aLow)/2)+aLow;var cmp=aCompare(aNeedle,aHaystack[mid],true);if(cmp===0){// Found the element we are looking for.\nreturn mid;}else if(cmp>0){// Our needle is greater than aHaystack[mid].\nif(aHigh-mid>1){// The element is in the upper half.\nreturn recursiveSearch(mid,aHigh,aNeedle,aHaystack,aCompare,aBias);}// The exact needle element was not found in this haystack. Determine if\n// we are in termination case (3) or (2) and return the appropriate thing.\nif(aBias==exports.LEAST_UPPER_BOUND){return aHigh<aHaystack.length?aHigh:-1;}else{return mid;}}else{// Our needle is less than aHaystack[mid].\nif(mid-aLow>1){// The element is in the lower half.\nreturn recursiveSearch(aLow,mid,aNeedle,aHaystack,aCompare,aBias);}// we are in termination case (3) or (2) and return the appropriate thing.\nif(aBias==exports.LEAST_UPPER_BOUND){return mid;}else{return aLow<0?-1:aLow;}}}/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */exports.search=function search(aNeedle,aHaystack,aCompare,aBias){if(aHaystack.length===0){return-1;}var index=recursiveSearch(-1,aHaystack.length,aNeedle,aHaystack,aCompare,aBias||exports.GREATEST_LOWER_BOUND);if(index<0){return-1;}// We have found either the exact element, or the next-closest element than\n// the one we are searching for. However, there may be more than one such\n// element. Make sure we always return the smallest of these.\nwhile(index-1>=0){if(aCompare(aHaystack[index],aHaystack[index-1],true)!==0){break;}--index;}return index;};","map":{"version":3,"names":["exports","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","recursiveSearch","aLow","aHigh","aNeedle","aHaystack","aCompare","aBias","mid","Math","floor","cmp","length","search","index"],"sources":["/Users/fernandorojo/Developer/messing/rea-tree/node_modules/@expo/webpack-config/node_modules/source-map/lib/binary-search.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n"],"mappings":"AAAA,2C,CACA;AACA;AACA;AACA;AACA,GAEAA,OAAO,CAACC,oBAAR,CAA+B,CAA/B,CACAD,OAAO,CAACE,iBAAR,CAA4B,CAA5B,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAASC,CAAAA,eAAT,CAAyBC,IAAzB,CAA+BC,KAA/B,CAAsCC,OAAtC,CAA+CC,SAA/C,CAA0DC,QAA1D,CAAoEC,KAApE,CAA2E,CACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAIC,CAAAA,GAAG,CAAGC,IAAI,CAACC,KAAL,CAAW,CAACP,KAAK,CAAGD,IAAT,EAAiB,CAA5B,EAAiCA,IAA3C,CACA,GAAIS,CAAAA,GAAG,CAAGL,QAAQ,CAACF,OAAD,CAAUC,SAAS,CAACG,GAAD,CAAnB,CAA0B,IAA1B,CAAlB,CACA,GAAIG,GAAG,GAAK,CAAZ,CAAe,CACb;AACA,MAAOH,CAAAA,GAAP,CACD,CAHD,IAIK,IAAIG,GAAG,CAAG,CAAV,CAAa,CAChB;AACA,GAAIR,KAAK,CAAGK,GAAR,CAAc,CAAlB,CAAqB,CACnB;AACA,MAAOP,CAAAA,eAAe,CAACO,GAAD,CAAML,KAAN,CAAaC,OAAb,CAAsBC,SAAtB,CAAiCC,QAAjC,CAA2CC,KAA3C,CAAtB,CACD,CAED;AACA;AACA,GAAIA,KAAK,EAAIT,OAAO,CAACE,iBAArB,CAAwC,CACtC,MAAOG,CAAAA,KAAK,CAAGE,SAAS,CAACO,MAAlB,CAA2BT,KAA3B,CAAmC,CAAC,CAA3C,CACD,CAFD,IAEO,CACL,MAAOK,CAAAA,GAAP,CACD,CACF,CAdI,IAeA,CACH;AACA,GAAIA,GAAG,CAAGN,IAAN,CAAa,CAAjB,CAAoB,CAClB;AACA,MAAOD,CAAAA,eAAe,CAACC,IAAD,CAAOM,GAAP,CAAYJ,OAAZ,CAAqBC,SAArB,CAAgCC,QAAhC,CAA0CC,KAA1C,CAAtB,CACD,CAED;AACA,GAAIA,KAAK,EAAIT,OAAO,CAACE,iBAArB,CAAwC,CACtC,MAAOQ,CAAAA,GAAP,CACD,CAFD,IAEO,CACL,MAAON,CAAAA,IAAI,CAAG,CAAP,CAAW,CAAC,CAAZ,CAAgBA,IAAvB,CACD,CACF,CACF,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACAJ,OAAO,CAACe,MAAR,CAAiB,QAASA,CAAAA,MAAT,CAAgBT,OAAhB,CAAyBC,SAAzB,CAAoCC,QAApC,CAA8CC,KAA9C,CAAqD,CACpE,GAAIF,SAAS,CAACO,MAAV,GAAqB,CAAzB,CAA4B,CAC1B,MAAO,CAAC,CAAR,CACD,CAED,GAAIE,CAAAA,KAAK,CAAGb,eAAe,CAAC,CAAC,CAAF,CAAKI,SAAS,CAACO,MAAf,CAAuBR,OAAvB,CAAgCC,SAAhC,CACCC,QADD,CACWC,KAAK,EAAIT,OAAO,CAACC,oBAD5B,CAA3B,CAEA,GAAIe,KAAK,CAAG,CAAZ,CAAe,CACb,MAAO,CAAC,CAAR,CACD,CAED;AACA;AACA;AACA,MAAOA,KAAK,CAAG,CAAR,EAAa,CAApB,CAAuB,CACrB,GAAIR,QAAQ,CAACD,SAAS,CAACS,KAAD,CAAV,CAAmBT,SAAS,CAACS,KAAK,CAAG,CAAT,CAA5B,CAAyC,IAAzC,CAAR,GAA2D,CAA/D,CAAkE,CAChE,MACD,CACD,EAAEA,KAAF,CACD,CAED,MAAOA,CAAAA,KAAP,CACD,CAtBD"},"metadata":{},"sourceType":"script"}