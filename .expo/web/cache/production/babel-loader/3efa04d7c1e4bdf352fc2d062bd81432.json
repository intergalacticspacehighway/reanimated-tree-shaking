{"ast":null,"code":"\"use strict\";var _regeneratorRuntime=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/regenerator\");var _asyncToGenerator=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator\");function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});exports.generateAsync=void 0;// Inspired by https://github.com/kevva/to-ico but reuses existing packages to keep bundle size small.\nvar parse_png_1=__importDefault(require(\"parse-png\"));var constants={directorySize:16,bitmapSize:40,headerSize:6,colorMode:0};function createHeader(header){var buffer=Buffer.alloc(constants.headerSize);buffer.writeUInt16LE(0,0);buffer.writeUInt16LE(1,2);buffer.writeUInt16LE(header,4);return buffer;}function createDirectory(data,offset){var buffer=Buffer.alloc(constants.directorySize);var size=data.data.length+constants.bitmapSize;var width=data.width===256?0:data.width;var height=data.height===256?0:data.height;var bpp=data.bpp*8;buffer.writeUInt8(width,0);buffer.writeUInt8(height,1);buffer.writeUInt8(0,2);buffer.writeUInt8(0,3);buffer.writeUInt16LE(1,4);buffer.writeUInt16LE(bpp,6);buffer.writeUInt32LE(size,8);buffer.writeUInt32LE(offset,12);return buffer;}function createBitmap(data,compression){var buffer=Buffer.alloc(constants.bitmapSize);buffer.writeUInt32LE(constants.bitmapSize,0);buffer.writeInt32LE(data.width,4);buffer.writeInt32LE(data.height*2,8);buffer.writeUInt16LE(1,12);buffer.writeUInt16LE(data.bpp*8,14);buffer.writeUInt32LE(compression,16);buffer.writeUInt32LE(data.data.length,20);buffer.writeInt32LE(0,24);buffer.writeInt32LE(0,28);buffer.writeUInt32LE(0,32);buffer.writeUInt32LE(0,36);return buffer;}function createDIB(data,width,height,bpp){var cols=width*bpp;var rows=height*cols;var end=rows-cols;var buffer=Buffer.alloc(data.length);for(var row=0;row<rows;row+=cols){for(var col=0;col<cols;col+=bpp){var pos=row+col;var r=data.readUInt8(pos);var g=data.readUInt8(pos+1);var b=data.readUInt8(pos+2);var a=data.readUInt8(pos+3);pos=end-row+col;buffer.writeUInt8(b,pos);buffer.writeUInt8(g,pos+1);buffer.writeUInt8(r,pos+2);buffer.writeUInt8(a,pos+3);}}return buffer;}function generateFromPNGs(pngs){var header=createHeader(pngs.length);var arr=[header];var len=header.length;var offset=constants.headerSize+constants.directorySize*pngs.length;var _iterator=_createForOfIteratorHelper(pngs),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var png=_step.value;var dir=createDirectory(png,offset);arr.push(dir);len+=dir.length;offset+=png.data.length+constants.bitmapSize;}}catch(err){_iterator.e(err);}finally{_iterator.f();}var _iterator2=_createForOfIteratorHelper(pngs),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var _png=_step2.value;var _header=createBitmap(_png,constants.colorMode);var dib=createDIB(_png.data,_png.width,_png.height,_png.bpp);arr.push(_header,dib);len+=_header.length+dib.length;}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return Buffer.concat(arr,len);}function generateAsync(_x){return _generateAsync.apply(this,arguments);}function _generateAsync(){_generateAsync=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(buffers){var pngs;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return Promise.all(buffers.map(function(x){return(0,parse_png_1[\"default\"])(x);}));case 2:pngs=_context.sent;return _context.abrupt(\"return\",generateFromPNGs(pngs));case 4:case\"end\":return _context.stop();}}},_callee);}));return _generateAsync.apply(this,arguments);}exports.generateAsync=generateAsync;","map":{"version":3,"sources":["../src/Ico.ts"],"names":[],"mappings":"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","sourcesContent":["// Inspired by https://github.com/kevva/to-ico but reuses existing packages to keep bundle size small.\nimport parsePng from 'parse-png';\n\ntype PNG = {\n  data: Buffer;\n  width: number;\n  height: number;\n  bpp: number;\n};\n\nconst constants = {\n  directorySize: 16,\n  bitmapSize: 40,\n  headerSize: 6,\n  colorMode: 0,\n};\n\nfunction createHeader(header: number): Buffer {\n  const buffer = Buffer.alloc(constants.headerSize);\n\n  buffer.writeUInt16LE(0, 0);\n  buffer.writeUInt16LE(1, 2);\n  buffer.writeUInt16LE(header, 4);\n\n  return buffer;\n}\n\nfunction createDirectory(data: PNG, offset: number): Buffer {\n  const buffer = Buffer.alloc(constants.directorySize);\n  const size = data.data.length + constants.bitmapSize;\n  const width = data.width === 256 ? 0 : data.width;\n  const height = data.height === 256 ? 0 : data.height;\n  const bpp = data.bpp * 8;\n\n  buffer.writeUInt8(width, 0);\n  buffer.writeUInt8(height, 1);\n  buffer.writeUInt8(0, 2);\n  buffer.writeUInt8(0, 3);\n  buffer.writeUInt16LE(1, 4);\n  buffer.writeUInt16LE(bpp, 6);\n  buffer.writeUInt32LE(size, 8);\n  buffer.writeUInt32LE(offset, 12);\n\n  return buffer;\n}\n\nfunction createBitmap(data: PNG, compression: number): Buffer {\n  const buffer = Buffer.alloc(constants.bitmapSize);\n\n  buffer.writeUInt32LE(constants.bitmapSize, 0);\n  buffer.writeInt32LE(data.width, 4);\n  buffer.writeInt32LE(data.height * 2, 8);\n  buffer.writeUInt16LE(1, 12);\n  buffer.writeUInt16LE(data.bpp * 8, 14);\n  buffer.writeUInt32LE(compression, 16);\n  buffer.writeUInt32LE(data.data.length, 20);\n  buffer.writeInt32LE(0, 24);\n  buffer.writeInt32LE(0, 28);\n  buffer.writeUInt32LE(0, 32);\n  buffer.writeUInt32LE(0, 36);\n\n  return buffer;\n}\n\nfunction createDIB(data: Buffer, width: number, height: number, bpp: number): Buffer {\n  const cols = width * bpp;\n  const rows = height * cols;\n  const end = rows - cols;\n  const buffer = Buffer.alloc(data.length);\n\n  for (let row = 0; row < rows; row += cols) {\n    for (let col = 0; col < cols; col += bpp) {\n      let pos = row + col;\n\n      const r = data.readUInt8(pos);\n      const g = data.readUInt8(pos + 1);\n      const b = data.readUInt8(pos + 2);\n      const a = data.readUInt8(pos + 3);\n\n      pos = end - row + col;\n\n      buffer.writeUInt8(b, pos);\n      buffer.writeUInt8(g, pos + 1);\n      buffer.writeUInt8(r, pos + 2);\n      buffer.writeUInt8(a, pos + 3);\n    }\n  }\n\n  return buffer;\n}\n\nfunction generateFromPNGs(pngs: PNG[]): Buffer {\n  const header = createHeader(pngs.length);\n  const arr = [header];\n\n  let len = header.length;\n  let offset = constants.headerSize + constants.directorySize * pngs.length;\n\n  for (const png of pngs) {\n    const dir = createDirectory(png, offset);\n    arr.push(dir);\n    len += dir.length;\n    offset += png.data.length + constants.bitmapSize;\n  }\n\n  for (const png of pngs) {\n    const header = createBitmap(png, constants.colorMode);\n    const dib = createDIB(png.data, png.width, png.height, png.bpp);\n    arr.push(header, dib);\n    len += header.length + dib.length;\n  }\n\n  return Buffer.concat(arr, len);\n}\n\nexport async function generateAsync(buffers: Buffer[]): Promise<Buffer> {\n  const pngs: PNG[] = await Promise.all(buffers.map(x => parsePng(x)));\n  return generateFromPNGs(pngs);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}