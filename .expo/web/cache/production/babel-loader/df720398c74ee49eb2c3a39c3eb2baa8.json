{"ast":null,"code":"\"use strict\";function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.ensureSlash=ensureSlash;exports.getEntryPoint=getEntryPoint;exports.getEntryPointWithExtensions=getEntryPointWithExtensions;exports.getFileWithExtensions=getFileWithExtensions;exports.getPossibleProjectRoot=getPossibleProjectRoot;exports.resolveEntryPoint=resolveEntryPoint;exports.resolveFromSilentWithExtensions=resolveFromSilentWithExtensions;function _fs(){var data=_interopRequireDefault(require(\"fs\"));_fs=function _fs(){return data;};return data;}function _path(){var data=_interopRequireDefault(require(\"path\"));_path=function _path(){return data;};return data;}function _resolveFrom(){var data=_interopRequireDefault(require(\"resolve-from\"));_resolveFrom=function _resolveFrom(){return data;};return data;}function _Config(){var data=require(\"../Config\");_Config=function _Config(){return data;};return data;}function _extensions(){var data=require(\"./extensions\");_extensions=function _extensions(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}// https://github.com/facebook/create-react-app/blob/9750738cce89a967cc71f28390daf5d4311b193c/packages/react-scripts/config/paths.js#L22\nfunction ensureSlash(inputPath,needsSlash){var hasSlash=inputPath.endsWith('/');if(hasSlash&&!needsSlash){return inputPath.substr(0,inputPath.length-1);}else if(!hasSlash&&needsSlash){return\"\".concat(inputPath,\"/\");}else{return inputPath;}}function getPossibleProjectRoot(){return _fs()[\"default\"].realpathSync(process.cwd());}var nativePlatforms=['ios','android'];function resolveEntryPoint(projectRoot,_ref){var platform=_ref.platform,projectConfig=_ref.projectConfig;var platforms=nativePlatforms.includes(platform)?[platform,'native']:[platform];return getEntryPoint(projectRoot,['./index'],platforms,projectConfig);}function getEntryPoint(projectRoot,entryFiles,platforms,projectConfig){var extensions=(0,_extensions().getBareExtensions)(platforms);return getEntryPointWithExtensions(projectRoot,entryFiles,extensions,projectConfig);}// Used to resolve the main entry file for a project.\nfunction getEntryPointWithExtensions(projectRoot,entryFiles,extensions,projectConfig){var _ref2=projectConfig!==null&&projectConfig!==void 0?projectConfig:(0,_Config().getConfig)(projectRoot,{skipSDKVersionRequirement:true}),exp=_ref2.exp,pkg=_ref2.pkg;// This will first look in the `app.json`s `expo.entryPoint` field for a potential main file.\n// We check the Expo config first in case you want your project to start differently with Expo then in a standalone environment.\nif(exp&&exp.entryPoint&&typeof exp.entryPoint==='string'){// If the field exists then we want to test it against every one of the supplied extensions\n// to ensure the bundler resolves the same way.\nvar entry=getFileWithExtensions(projectRoot,exp.entryPoint,extensions);if(!entry){// Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\nentry=resolveFromSilentWithExtensions(projectRoot,exp.entryPoint,extensions);// If it doesn't resolve then just return the entryPoint as-is. This makes\n// it possible for people who have an unconventional setup (eg: multiple\n// apps in monorepo with metro at root) to customize entry point without\n// us imposing our assumptions.\nif(!entry){return exp.entryPoint;}}return entry;}else if(pkg){// If the config doesn't define a custom entry then we want to look at the `package.json`s `main` field, and try again.\nvar main=pkg.main;if(main&&typeof main==='string'){// Testing the main field against all of the provided extensions - for legacy reasons we can't use node module resolution as the package.json allows you to pass in a file without a relative path and expect it as a relative path.\nvar _entry=getFileWithExtensions(projectRoot,main,extensions);if(!_entry){// Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n_entry=resolveFromSilentWithExtensions(projectRoot,main,extensions);if(!_entry)throw new Error(\"Cannot resolve entry file: The `main` field defined in your `package.json` points to a non-existent path.\");}return _entry;}}// Now we will start looking for a default entry point using the provided `entryFiles` argument.\n// This will add support for create-react-app (src/index.js) and react-native-cli (index.js) which don't define a main.\nvar _iterator=_createForOfIteratorHelper(entryFiles),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var fileName=_step.value;var _entry2=resolveFromSilentWithExtensions(projectRoot,fileName,extensions);if(_entry2)return _entry2;}}catch(err){_iterator.e(err);}finally{_iterator.f();}try{// If none of the default files exist then we will attempt to use the main Expo entry point.\n// This requires `expo` to be installed in the project to work as it will use `node_module/expo/AppEntry.js`\n// Doing this enables us to create a bare minimum Expo project.\n// TODO(Bacon): We may want to do a check against `./App` and `expo` in the `package.json` `dependencies` as we can more accurately ensure that the project is expo-min without needing the modules installed.\nreturn(0,_resolveFrom()[\"default\"])(projectRoot,'expo/AppEntry');}catch(_unused){throw new Error(\"The project entry file could not be resolved. Please either define it in the `package.json` (main), `app.json` (expo.entryPoint), create an `index.js`, or install the `expo` package.\");}}// Resolve from but with the ability to resolve like a bundler\nfunction resolveFromSilentWithExtensions(fromDirectory,moduleId,extensions){var _iterator2=_createForOfIteratorHelper(extensions),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var extension=_step2.value;var modulePath=_resolveFrom()[\"default\"].silent(fromDirectory,\"\".concat(moduleId,\".\").concat(extension));if(modulePath&&modulePath.endsWith(extension)){return modulePath;}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return _resolveFrom()[\"default\"].silent(fromDirectory,moduleId)||null;}// Statically attempt to resolve a module but with the ability to resolve like a bundler.\n// This won't use node module resolution.\nfunction getFileWithExtensions(fromDirectory,moduleId,extensions){var modulePath=_path()[\"default\"].join(fromDirectory,moduleId);if(_fs()[\"default\"].existsSync(modulePath)){return modulePath;}var _iterator3=_createForOfIteratorHelper(extensions),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var extension=_step3.value;var _modulePath=_path()[\"default\"].join(fromDirectory,\"\".concat(moduleId,\".\").concat(extension));if(_fs()[\"default\"].existsSync(_modulePath)){return _modulePath;}}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return null;}","map":{"version":3,"sources":["../../src/paths/paths.ts"],"names":["hasSlash","inputPath","fs","process","nativePlatforms","projectConfig","platforms","getEntryPoint","extensions","getEntryPointWithExtensions","pkg","skipSDKVersionRequirement","exp","entry","getFileWithExtensions","resolveFromSilentWithExtensions","main","modulePath","resolveFrom","moduleId","path"],"mappings":"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","sourcesContent":["import fs from 'fs';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { getConfig } from '../Config';\nimport { ProjectConfig } from '../Config.types';\nimport { getBareExtensions } from './extensions';\n\n// https://github.com/facebook/create-react-app/blob/9750738cce89a967cc71f28390daf5d4311b193c/packages/react-scripts/config/paths.js#L22\nexport function ensureSlash(inputPath: string, needsSlash: boolean): string {\n  const hasSlash = inputPath.endsWith('/');\n  if (hasSlash && !needsSlash) {\n    return inputPath.substr(0, inputPath.length - 1);\n  } else if (!hasSlash && needsSlash) {\n    return `${inputPath}/`;\n  } else {\n    return inputPath;\n  }\n}\n\nexport function getPossibleProjectRoot(): string {\n  return fs.realpathSync(process.cwd());\n}\n\nconst nativePlatforms = ['ios', 'android'];\n\nexport function resolveEntryPoint(\n  projectRoot: string,\n  { platform, projectConfig }: { platform: string; projectConfig?: ProjectConfig }\n) {\n  const platforms = nativePlatforms.includes(platform) ? [platform, 'native'] : [platform];\n  return getEntryPoint(projectRoot, ['./index'], platforms, projectConfig);\n}\n\nexport function getEntryPoint(\n  projectRoot: string,\n  entryFiles: string[],\n  platforms: string[],\n  projectConfig?: ProjectConfig\n): string | null {\n  const extensions = getBareExtensions(platforms);\n  return getEntryPointWithExtensions(projectRoot, entryFiles, extensions, projectConfig);\n}\n\n// Used to resolve the main entry file for a project.\nexport function getEntryPointWithExtensions(\n  projectRoot: string,\n  entryFiles: string[],\n  extensions: string[],\n  projectConfig?: ProjectConfig\n): string {\n  const { exp, pkg } = projectConfig ?? getConfig(projectRoot, { skipSDKVersionRequirement: true });\n\n  // This will first look in the `app.json`s `expo.entryPoint` field for a potential main file.\n  // We check the Expo config first in case you want your project to start differently with Expo then in a standalone environment.\n  if (exp && exp.entryPoint && typeof exp.entryPoint === 'string') {\n    // If the field exists then we want to test it against every one of the supplied extensions\n    // to ensure the bundler resolves the same way.\n    let entry = getFileWithExtensions(projectRoot, exp.entryPoint, extensions);\n    if (!entry) {\n      // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n      entry = resolveFromSilentWithExtensions(projectRoot, exp.entryPoint, extensions);\n\n      // If it doesn't resolve then just return the entryPoint as-is. This makes\n      // it possible for people who have an unconventional setup (eg: multiple\n      // apps in monorepo with metro at root) to customize entry point without\n      // us imposing our assumptions.\n      if (!entry) {\n        return exp.entryPoint;\n      }\n    }\n    return entry;\n  } else if (pkg) {\n    // If the config doesn't define a custom entry then we want to look at the `package.json`s `main` field, and try again.\n    const { main } = pkg;\n    if (main && typeof main === 'string') {\n      // Testing the main field against all of the provided extensions - for legacy reasons we can't use node module resolution as the package.json allows you to pass in a file without a relative path and expect it as a relative path.\n      let entry = getFileWithExtensions(projectRoot, main, extensions);\n      if (!entry) {\n        // Allow for paths like: `{ \"main\": \"expo/AppEntry\" }`\n        entry = resolveFromSilentWithExtensions(projectRoot, main, extensions);\n        if (!entry)\n          throw new Error(\n            `Cannot resolve entry file: The \\`main\\` field defined in your \\`package.json\\` points to a non-existent path.`\n          );\n      }\n      return entry;\n    }\n  }\n\n  // Now we will start looking for a default entry point using the provided `entryFiles` argument.\n  // This will add support for create-react-app (src/index.js) and react-native-cli (index.js) which don't define a main.\n  for (const fileName of entryFiles) {\n    const entry = resolveFromSilentWithExtensions(projectRoot, fileName, extensions);\n    if (entry) return entry;\n  }\n\n  try {\n    // If none of the default files exist then we will attempt to use the main Expo entry point.\n    // This requires `expo` to be installed in the project to work as it will use `node_module/expo/AppEntry.js`\n    // Doing this enables us to create a bare minimum Expo project.\n\n    // TODO(Bacon): We may want to do a check against `./App` and `expo` in the `package.json` `dependencies` as we can more accurately ensure that the project is expo-min without needing the modules installed.\n    return resolveFrom(projectRoot, 'expo/AppEntry');\n  } catch {\n    throw new Error(\n      `The project entry file could not be resolved. Please either define it in the \\`package.json\\` (main), \\`app.json\\` (expo.entryPoint), create an \\`index.js\\`, or install the \\`expo\\` package.`\n    );\n  }\n}\n\n// Resolve from but with the ability to resolve like a bundler\nexport function resolveFromSilentWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  for (const extension of extensions) {\n    const modulePath = resolveFrom.silent(fromDirectory, `${moduleId}.${extension}`);\n    if (modulePath && modulePath.endsWith(extension)) {\n      return modulePath;\n    }\n  }\n  return resolveFrom.silent(fromDirectory, moduleId) || null;\n}\n\n// Statically attempt to resolve a module but with the ability to resolve like a bundler.\n// This won't use node module resolution.\nexport function getFileWithExtensions(\n  fromDirectory: string,\n  moduleId: string,\n  extensions: string[]\n): string | null {\n  const modulePath = path.join(fromDirectory, moduleId);\n  if (fs.existsSync(modulePath)) {\n    return modulePath;\n  }\n  for (const extension of extensions) {\n    const modulePath = path.join(fromDirectory, `${moduleId}.${extension}`);\n    if (fs.existsSync(modulePath)) {\n      return modulePath;\n    }\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"script"}