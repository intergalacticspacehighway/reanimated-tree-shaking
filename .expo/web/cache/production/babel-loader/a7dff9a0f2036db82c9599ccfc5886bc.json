{"ast":null,"code":"\"use strict\";exports.__esModule=true;exports[\"default\"]=void 0;var _Dimensions=_interopRequireDefault(require(\"../../exports/Dimensions\"));var _findNodeHandle=_interopRequireDefault(require(\"../../exports/findNodeHandle\"));var _invariant=_interopRequireDefault(require(\"fbjs/lib/invariant\"));var _Platform=_interopRequireDefault(require(\"../../exports/Platform\"));var _TextInputState=_interopRequireDefault(require(\"../TextInputState\"));var _UIManager=_interopRequireDefault(require(\"../../exports/UIManager\"));var _warning=_interopRequireDefault(require(\"fbjs/lib/warning\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */ /**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */var emptyObject={};var IS_ANIMATING_TOUCH_START_THRESHOLD_MS=16;var ScrollResponderMixin={// mixins: [Subscribable.Mixin],\nscrollResponderMixinGetInitialState:function scrollResponderMixinGetInitialState(){return{isTouching:false,lastMomentumScrollBeginTime:0,lastMomentumScrollEndTime:0,// Reset to false every time becomes responder. This is used to:\n// - Determine if the scroll view has been scrolled and therefore should\n// refuse to give up its responder lock.\n// - Determine if releasing should dismiss the keyboard when we are in\n// tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).\nobservedScrollSinceBecomingResponder:false,becameResponderWhileAnimating:false};},/**\n   * Invoke this from an `onScroll` event.\n   */scrollResponderHandleScrollShouldSetResponder:function scrollResponderHandleScrollShouldSetResponder(){return this.state.isTouching;},/**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */scrollResponderHandleStartShouldSetResponder:function scrollResponderHandleStartShouldSetResponder(){return false;},/**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */scrollResponderHandleStartShouldSetResponderCapture:function scrollResponderHandleStartShouldSetResponderCapture(e){// First see if we want to eat taps while the keyboard is up\n// var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n// if (!this.props.keyboardShouldPersistTaps &&\n//   currentlyFocusedTextInput != null &&\n//   e.target !== currentlyFocusedTextInput) {\n//   return true;\n// }\nreturn this.scrollResponderIsAnimating();},/**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */scrollResponderHandleResponderReject:function scrollResponderHandleResponderReject(){(0,_warning[\"default\"])(false,\"ScrollView doesn't take rejection well - scrolls anyway\");},/**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */scrollResponderHandleTerminationRequest:function scrollResponderHandleTerminationRequest(){return!this.state.observedScrollSinceBecomingResponder;},/**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */scrollResponderHandleTouchEnd:function scrollResponderHandleTouchEnd(e){var nativeEvent=e.nativeEvent;this.state.isTouching=nativeEvent.touches.length!==0;this.props.onTouchEnd&&this.props.onTouchEnd(e);},/**\n   * Invoke this from an `onResponderRelease` event.\n   */scrollResponderHandleResponderRelease:function scrollResponderHandleResponderRelease(e){this.props.onResponderRelease&&this.props.onResponderRelease(e);// By default scroll views will unfocus a textField\n// if another touch occurs outside of it\nvar currentlyFocusedTextInput=_TextInputState[\"default\"].currentlyFocusedField();if(!this.props.keyboardShouldPersistTaps&&currentlyFocusedTextInput!=null&&e.target!==currentlyFocusedTextInput&&!this.state.observedScrollSinceBecomingResponder&&!this.state.becameResponderWhileAnimating){this.props.onScrollResponderKeyboardDismissed&&this.props.onScrollResponderKeyboardDismissed(e);_TextInputState[\"default\"].blurTextInput(currentlyFocusedTextInput);}},scrollResponderHandleScroll:function scrollResponderHandleScroll(e){this.state.observedScrollSinceBecomingResponder=true;this.props.onScroll&&this.props.onScroll(e);},/**\n   * Invoke this from an `onResponderGrant` event.\n   */scrollResponderHandleResponderGrant:function scrollResponderHandleResponderGrant(e){this.state.observedScrollSinceBecomingResponder=false;this.props.onResponderGrant&&this.props.onResponderGrant(e);this.state.becameResponderWhileAnimating=this.scrollResponderIsAnimating();},/**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */scrollResponderHandleScrollBeginDrag:function scrollResponderHandleScrollBeginDrag(e){this.props.onScrollBeginDrag&&this.props.onScrollBeginDrag(e);},/**\n   * Invoke this from an `onScrollEndDrag` event.\n   */scrollResponderHandleScrollEndDrag:function scrollResponderHandleScrollEndDrag(e){this.props.onScrollEndDrag&&this.props.onScrollEndDrag(e);},/**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */scrollResponderHandleMomentumScrollBegin:function scrollResponderHandleMomentumScrollBegin(e){this.state.lastMomentumScrollBeginTime=Date.now();this.props.onMomentumScrollBegin&&this.props.onMomentumScrollBegin(e);},/**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */scrollResponderHandleMomentumScrollEnd:function scrollResponderHandleMomentumScrollEnd(e){this.state.lastMomentumScrollEndTime=Date.now();this.props.onMomentumScrollEnd&&this.props.onMomentumScrollEnd(e);},/**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */scrollResponderHandleTouchStart:function scrollResponderHandleTouchStart(e){this.state.isTouching=true;this.props.onTouchStart&&this.props.onTouchStart(e);},/**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */scrollResponderHandleTouchMove:function scrollResponderHandleTouchMove(e){this.props.onTouchMove&&this.props.onTouchMove(e);},/**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */scrollResponderIsAnimating:function scrollResponderIsAnimating(){var now=Date.now();var timeSinceLastMomentumScrollEnd=now-this.state.lastMomentumScrollEndTime;var isAnimating=timeSinceLastMomentumScrollEnd<IS_ANIMATING_TOUCH_START_THRESHOLD_MS||this.state.lastMomentumScrollEndTime<this.state.lastMomentumScrollBeginTime;return isAnimating;},/**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */scrollResponderGetScrollableNode:function scrollResponderGetScrollableNode(){return this.getScrollableNode?this.getScrollableNode():(0,_findNodeHandle[\"default\"])(this);},/**\n   * A helper function to scroll to a specific point in the scrollview.\n   * This is currently used to help focus on child textviews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */scrollResponderScrollTo:function scrollResponderScrollTo(x,y,animated){if(typeof x==='number'){console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');}else{var _ref=x||emptyObject;x=_ref.x;y=_ref.y;animated=_ref.animated;}var node=this.scrollResponderGetScrollableNode();var left=x||0;var top=y||0;if(typeof node.scroll==='function'){node.scroll({top:top,left:left,behavior:!animated?'auto':'smooth'});}else{node.scrollLeft=left;node.scrollTop=top;}},/**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */scrollResponderZoomTo:function scrollResponderZoomTo(rect,animated)// deprecated, put this inside the rect argument instead\n{if(_Platform[\"default\"].OS!=='ios'){(0,_invariant[\"default\"])('zoomToRect is not implemented');}},/**\n   * Displays the scroll indicators momentarily.\n   */scrollResponderFlashScrollIndicators:function scrollResponderFlashScrollIndicators(){},/**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */scrollResponderScrollNativeHandleToKeyboard:function scrollResponderScrollNativeHandleToKeyboard(nodeHandle,additionalOffset,preventNegativeScrollOffset){this.additionalScrollOffset=additionalOffset||0;this.preventNegativeScrollOffset=!!preventNegativeScrollOffset;_UIManager[\"default\"].measureLayout(nodeHandle,(0,_findNodeHandle[\"default\"])(this.getInnerViewNode()),this.scrollResponderTextInputFocusError,this.scrollResponderInputMeasureAndScrollToKeyboard);},/**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */scrollResponderInputMeasureAndScrollToKeyboard:function scrollResponderInputMeasureAndScrollToKeyboard(left,top,width,height){var keyboardScreenY=_Dimensions[\"default\"].get('window').height;if(this.keyboardWillOpenTo){keyboardScreenY=this.keyboardWillOpenTo.endCoordinates.screenY;}var scrollOffsetY=top-keyboardScreenY+height+this.additionalScrollOffset;// By default, this can scroll with negative offset, pulling the content\n// down so that the target component's bottom meets the keyboard's top.\n// If requested otherwise, cap the offset at 0 minimum to avoid content\n// shifting down.\nif(this.preventNegativeScrollOffset){scrollOffsetY=Math.max(0,scrollOffsetY);}this.scrollResponderScrollTo({x:0,y:scrollOffsetY,animated:true});this.additionalOffset=0;this.preventNegativeScrollOffset=false;},scrollResponderTextInputFocusError:function scrollResponderTextInputFocusError(e){console.error('Error measuring text field: ',e);},/**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */UNSAFE_componentWillMount:function UNSAFE_componentWillMount(){this.keyboardWillOpenTo=null;this.additionalScrollOffset=0;// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);\n// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);\n// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);\n// this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);\n},/**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */scrollResponderKeyboardWillShow:function scrollResponderKeyboardWillShow(e){this.keyboardWillOpenTo=e;this.props.onKeyboardWillShow&&this.props.onKeyboardWillShow(e);},scrollResponderKeyboardWillHide:function scrollResponderKeyboardWillHide(e){this.keyboardWillOpenTo=null;this.props.onKeyboardWillHide&&this.props.onKeyboardWillHide(e);},scrollResponderKeyboardDidShow:function scrollResponderKeyboardDidShow(e){// TODO(7693961): The event for DidShow is not available on iOS yet.\n// Use the one from WillShow and do not assign.\nif(e){this.keyboardWillOpenTo=e;}this.props.onKeyboardDidShow&&this.props.onKeyboardDidShow(e);},scrollResponderKeyboardDidHide:function scrollResponderKeyboardDidHide(e){this.keyboardWillOpenTo=null;this.props.onKeyboardDidHide&&this.props.onKeyboardDidHide(e);}};var ScrollResponder={Mixin:ScrollResponderMixin};var _default=ScrollResponder;exports[\"default\"]=_default;module.exports=exports[\"default\"];","map":{"version":3,"names":["exports","__esModule","_Dimensions","_interopRequireDefault","require","_findNodeHandle","_invariant","_Platform","_TextInputState","_UIManager","_warning","obj","emptyObject","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollResponderMixin","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","state","scrollResponderHandleStartShouldSetResponder","scrollResponderHandleStartShouldSetResponderCapture","e","scrollResponderIsAnimating","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","props","onTouchEnd","scrollResponderHandleResponderRelease","onResponderRelease","currentlyFocusedTextInput","currentlyFocusedField","keyboardShouldPersistTaps","target","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","Date","now","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","getScrollableNode","scrollResponderScrollTo","x","y","animated","console","warn","_ref","node","left","top","scroll","behavior","scrollLeft","scrollTop","scrollResponderZoomTo","rect","OS","scrollResponderFlashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","width","height","keyboardScreenY","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","error","UNSAFE_componentWillMount","scrollResponderKeyboardWillShow","onKeyboardWillShow","scrollResponderKeyboardWillHide","onKeyboardWillHide","scrollResponderKeyboardDidShow","onKeyboardDidShow","scrollResponderKeyboardDidHide","onKeyboardDidHide","ScrollResponder","Mixin","_default","module"],"sources":["/Users/fernandorojo/Developer/messing/rea-tree/node_modules/react-native-web/dist/cjs/modules/ScrollResponder/index.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _Dimensions = _interopRequireDefault(require(\"../../exports/Dimensions\"));\n\nvar _findNodeHandle = _interopRequireDefault(require(\"../../exports/findNodeHandle\"));\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nvar _Platform = _interopRequireDefault(require(\"../../exports/Platform\"));\n\nvar _TextInputState = _interopRequireDefault(require(\"../TextInputState\"));\n\nvar _UIManager = _interopRequireDefault(require(\"../../exports/UIManager\"));\n\nvar _warning = _interopRequireDefault(require(\"fbjs/lib/warning\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\nvar emptyObject = {};\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nvar ScrollResponderMixin = {\n  // mixins: [Subscribable.Mixin],\n  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n      // Reset to false every time becomes responder. This is used to:\n      // - Determine if the scroll view has been scrolled and therefore should\n      // refuse to give up its responder lock.\n      // - Determine if releasing should dismiss the keyboard when we are in\n      // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false\n    };\n  },\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {\n    return this.state.isTouching;\n  },\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {\n    return false;\n  },\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {\n    // First see if we want to eat taps while the keyboard is up\n    // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    // if (!this.props.keyboardShouldPersistTaps &&\n    //   currentlyFocusedTextInput != null &&\n    //   e.target !== currentlyFocusedTextInput) {\n    //   return true;\n    // }\n    return this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {\n    (0, _warning.default)(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n  },\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\n  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {\n    var nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e); // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n\n    var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedField();\n\n    if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {\n      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n\n      _TextInputState.default.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {\n    this.state.lastMomentumScrollBeginTime = Date.now();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {\n    this.state.lastMomentumScrollEndTime = Date.now();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  scrollResponderIsAnimating: function scrollResponderIsAnimating() {\n    var now = Date.now();\n    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;\n    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n\n  /**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\n  scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {\n    return this.getScrollableNode ? this.getScrollableNode() : (0, _findNodeHandle.default)(this);\n  },\n\n  /**\n   * A helper function to scroll to a specific point in the scrollview.\n   * This is currently used to help focus on child textviews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {\n    if (typeof x === 'number') {\n      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n    } else {\n      var _ref = x || emptyObject;\n\n      x = _ref.x;\n      y = _ref.y;\n      animated = _ref.animated;\n    }\n\n    var node = this.scrollResponderGetScrollableNode();\n    var left = x || 0;\n    var top = y || 0;\n\n    if (typeof node.scroll === 'function') {\n      node.scroll({\n        top: top,\n        left: left,\n        behavior: !animated ? 'auto' : 'smooth'\n      });\n    } else {\n      node.scrollLeft = left;\n      node.scrollTop = top;\n    }\n  },\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) // deprecated, put this inside the rect argument instead\n  {\n    if (_Platform.default.OS !== 'ios') {\n      (0, _invariant.default)('zoomToRect is not implemented');\n    }\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {},\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n\n    _UIManager.default.measureLayout(nodeHandle, (0, _findNodeHandle.default)(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n  },\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {\n    var keyboardScreenY = _Dimensions.default.get('window').height;\n\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n\n    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset; // By default, this can scroll with negative offset, pulling the content\n    // down so that the target component's bottom meets the keyboard's top.\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\n    // shifting down.\n\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n\n    this.scrollResponderScrollTo({\n      x: 0,\n      y: scrollOffsetY,\n      animated: true\n    });\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {\n    console.error('Error measuring text field: ', e);\n  },\n\n  /**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\n  UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0; // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);\n  },\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\n    // Use the one from WillShow and do not assign.\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  }\n};\nvar ScrollResponder = {\n  Mixin: ScrollResponderMixin\n};\nvar _default = ScrollResponder;\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}