{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var SourceMapGenerator=require('./source-map-generator').SourceMapGenerator;var util=require('./util');// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE=/(\\r?\\n)/;// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE=10;// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode=\"$$$isSourceNode$$$\";/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */function SourceNode(aLine,aColumn,aSource,aChunks,aName){this.children=[];this.sourceContents={};this.line=aLine==null?null:aLine;this.column=aColumn==null?null:aColumn;this.source=aSource==null?null:aSource;this.name=aName==null?null:aName;this[isSourceNode]=true;if(aChunks!=null)this.add(aChunks);}/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */SourceNode.fromStringWithSourceMap=function SourceNode_fromStringWithSourceMap(aGeneratedCode,aSourceMapConsumer,aRelativePath){// The SourceNode we want to fill with the generated code\n// and the SourceMap\nvar node=new SourceNode();// All even indices of this array are one line of the generated code,\n// while all odd indices are the newlines between two adjacent lines\n// (since `REGEX_NEWLINE` captures its match).\n// Processed fragments are accessed by calling `shiftNextLine`.\nvar remainingLines=aGeneratedCode.split(REGEX_NEWLINE);var remainingLinesIndex=0;var shiftNextLine=function shiftNextLine(){var lineContents=getNextLine();// The last line of a file might not have a newline.\nvar newLine=getNextLine()||\"\";return lineContents+newLine;function getNextLine(){return remainingLinesIndex<remainingLines.length?remainingLines[remainingLinesIndex++]:undefined;}};// We need to remember the position of \"remainingLines\"\nvar lastGeneratedLine=1,lastGeneratedColumn=0;// The generate SourceNodes we need a code range.\n// To extract it current and last mapping is used.\n// Here we store the last mapping.\nvar lastMapping=null;aSourceMapConsumer.eachMapping(function(mapping){if(lastMapping!==null){// We add the code from \"lastMapping\" to \"mapping\":\n// First check if there is a new line in between.\nif(lastGeneratedLine<mapping.generatedLine){// Associate first line with \"lastMapping\"\naddMappingWithCode(lastMapping,shiftNextLine());lastGeneratedLine++;lastGeneratedColumn=0;// The remaining code is added without mapping\n}else{// There is no new line in between.\n// Associate the code between \"lastGeneratedColumn\" and\n// \"mapping.generatedColumn\" with \"lastMapping\"\nvar nextLine=remainingLines[remainingLinesIndex];var code=nextLine.substr(0,mapping.generatedColumn-lastGeneratedColumn);remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn-lastGeneratedColumn);lastGeneratedColumn=mapping.generatedColumn;addMappingWithCode(lastMapping,code);// No more remaining code, continue\nlastMapping=mapping;return;}}// We add the generated code until the first mapping\n// to the SourceNode without any mapping.\n// Each line is added as separate string.\nwhile(lastGeneratedLine<mapping.generatedLine){node.add(shiftNextLine());lastGeneratedLine++;}if(lastGeneratedColumn<mapping.generatedColumn){var nextLine=remainingLines[remainingLinesIndex];node.add(nextLine.substr(0,mapping.generatedColumn));remainingLines[remainingLinesIndex]=nextLine.substr(mapping.generatedColumn);lastGeneratedColumn=mapping.generatedColumn;}lastMapping=mapping;},this);// We have processed all mappings.\nif(remainingLinesIndex<remainingLines.length){if(lastMapping){// Associate the remaining code in the current line with \"lastMapping\"\naddMappingWithCode(lastMapping,shiftNextLine());}// and add the remaining lines without any mapping\nnode.add(remainingLines.splice(remainingLinesIndex).join(\"\"));}// Copy sourcesContent into SourceNode\naSourceMapConsumer.sources.forEach(function(sourceFile){var content=aSourceMapConsumer.sourceContentFor(sourceFile);if(content!=null){if(aRelativePath!=null){sourceFile=util.join(aRelativePath,sourceFile);}node.setSourceContent(sourceFile,content);}});return node;function addMappingWithCode(mapping,code){if(mapping===null||mapping.source===undefined){node.add(code);}else{var source=aRelativePath?util.join(aRelativePath,mapping.source):mapping.source;node.add(new SourceNode(mapping.originalLine,mapping.originalColumn,source,code,mapping.name));}}};/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */SourceNode.prototype.add=function SourceNode_add(aChunk){if(Array.isArray(aChunk)){aChunk.forEach(function(chunk){this.add(chunk);},this);}else if(aChunk[isSourceNode]||typeof aChunk===\"string\"){if(aChunk){this.children.push(aChunk);}}else{throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+aChunk);}return this;};/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */SourceNode.prototype.prepend=function SourceNode_prepend(aChunk){if(Array.isArray(aChunk)){for(var i=aChunk.length-1;i>=0;i--){this.prepend(aChunk[i]);}}else if(aChunk[isSourceNode]||typeof aChunk===\"string\"){this.children.unshift(aChunk);}else{throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \"+aChunk);}return this;};/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */SourceNode.prototype.walk=function SourceNode_walk(aFn){var chunk;for(var i=0,len=this.children.length;i<len;i++){chunk=this.children[i];if(chunk[isSourceNode]){chunk.walk(aFn);}else{if(chunk!==''){aFn(chunk,{source:this.source,line:this.line,column:this.column,name:this.name});}}}};/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */SourceNode.prototype.join=function SourceNode_join(aSep){var newChildren;var i;var len=this.children.length;if(len>0){newChildren=[];for(i=0;i<len-1;i++){newChildren.push(this.children[i]);newChildren.push(aSep);}newChildren.push(this.children[i]);this.children=newChildren;}return this;};/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */SourceNode.prototype.replaceRight=function SourceNode_replaceRight(aPattern,aReplacement){var lastChild=this.children[this.children.length-1];if(lastChild[isSourceNode]){lastChild.replaceRight(aPattern,aReplacement);}else if(typeof lastChild==='string'){this.children[this.children.length-1]=lastChild.replace(aPattern,aReplacement);}else{this.children.push(''.replace(aPattern,aReplacement));}return this;};/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */SourceNode.prototype.setSourceContent=function SourceNode_setSourceContent(aSourceFile,aSourceContent){this.sourceContents[util.toSetString(aSourceFile)]=aSourceContent;};/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */SourceNode.prototype.walkSourceContents=function SourceNode_walkSourceContents(aFn){for(var i=0,len=this.children.length;i<len;i++){if(this.children[i][isSourceNode]){this.children[i].walkSourceContents(aFn);}}var sources=Object.keys(this.sourceContents);for(var i=0,len=sources.length;i<len;i++){aFn(util.fromSetString(sources[i]),this.sourceContents[sources[i]]);}};/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */SourceNode.prototype.toString=function SourceNode_toString(){var str=\"\";this.walk(function(chunk){str+=chunk;});return str;};/**\n * Returns the string representation of this source node along with a source\n * map.\n */SourceNode.prototype.toStringWithSourceMap=function SourceNode_toStringWithSourceMap(aArgs){var generated={code:\"\",line:1,column:0};var map=new SourceMapGenerator(aArgs);var sourceMappingActive=false;var lastOriginalSource=null;var lastOriginalLine=null;var lastOriginalColumn=null;var lastOriginalName=null;this.walk(function(chunk,original){generated.code+=chunk;if(original.source!==null&&original.line!==null&&original.column!==null){if(lastOriginalSource!==original.source||lastOriginalLine!==original.line||lastOriginalColumn!==original.column||lastOriginalName!==original.name){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}lastOriginalSource=original.source;lastOriginalLine=original.line;lastOriginalColumn=original.column;lastOriginalName=original.name;sourceMappingActive=true;}else if(sourceMappingActive){map.addMapping({generated:{line:generated.line,column:generated.column}});lastOriginalSource=null;sourceMappingActive=false;}for(var idx=0,length=chunk.length;idx<length;idx++){if(chunk.charCodeAt(idx)===NEWLINE_CODE){generated.line++;generated.column=0;// Mappings end at eol\nif(idx+1===length){lastOriginalSource=null;sourceMappingActive=false;}else if(sourceMappingActive){map.addMapping({source:original.source,original:{line:original.line,column:original.column},generated:{line:generated.line,column:generated.column},name:original.name});}}else{generated.column++;}}});this.walkSourceContents(function(sourceFile,sourceContent){map.setSourceContent(sourceFile,sourceContent);});return{code:generated.code,map:map};};exports.SourceNode=SourceNode;","map":{"version":3,"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","length","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","addMappingWithCode","nextLine","code","substr","generatedColumn","splice","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","originalLine","originalColumn","prototype","SourceNode_add","aChunk","Array","isArray","chunk","push","TypeError","prepend","SourceNode_prepend","i","unshift","walk","SourceNode_walk","aFn","len","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","replace","SourceNode_setSourceContent","aSourceFile","aSourceContent","toSetString","walkSourceContents","SourceNode_walkSourceContents","Object","keys","fromSetString","toString","SourceNode_toString","str","toStringWithSourceMap","SourceNode_toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports"],"sources":["/Users/fernandorojo/Developer/messing/rea-tree/node_modules/@expo/webpack-config/node_modules/source-map/lib/source-node.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n"],"mappings":"AAAA,2C,CACA;AACA;AACA;AACA;AACA,GAEA,GAAIA,CAAAA,kBAAkB,CAAGC,OAAO,CAAC,wBAAD,CAAP,CAAkCD,kBAA3D,CACA,GAAIE,CAAAA,IAAI,CAAGD,OAAO,CAAC,QAAD,CAAlB,CAEA;AACA;AACA,GAAIE,CAAAA,aAAa,CAAG,SAApB,CAEA;AACA,GAAIC,CAAAA,YAAY,CAAG,EAAnB,CAEA;AACA;AACA;AACA,GAAIC,CAAAA,YAAY,CAAG,oBAAnB,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACA,QAASC,CAAAA,UAAT,CAAoBC,KAApB,CAA2BC,OAA3B,CAAoCC,OAApC,CAA6CC,OAA7C,CAAsDC,KAAtD,CAA6D,CAC3D,KAAKC,QAAL,CAAgB,EAAhB,CACA,KAAKC,cAAL,CAAsB,EAAtB,CACA,KAAKC,IAAL,CAAYP,KAAK,EAAI,IAAT,CAAgB,IAAhB,CAAuBA,KAAnC,CACA,KAAKQ,MAAL,CAAcP,OAAO,EAAI,IAAX,CAAkB,IAAlB,CAAyBA,OAAvC,CACA,KAAKQ,MAAL,CAAcP,OAAO,EAAI,IAAX,CAAkB,IAAlB,CAAyBA,OAAvC,CACA,KAAKQ,IAAL,CAAYN,KAAK,EAAI,IAAT,CAAgB,IAAhB,CAAuBA,KAAnC,CACA,KAAKN,YAAL,EAAqB,IAArB,CACA,GAAIK,OAAO,EAAI,IAAf,CAAqB,KAAKQ,GAAL,CAASR,OAAT,EACtB,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACAJ,UAAU,CAACa,uBAAX,CACE,QAASC,CAAAA,kCAAT,CAA4CC,cAA5C,CAA4DC,kBAA5D,CAAgFC,aAAhF,CAA+F,CAC7F;AACA;AACA,GAAIC,CAAAA,IAAI,CAAG,GAAIlB,CAAAA,UAAJ,EAAX,CAEA;AACA;AACA;AACA;AACA,GAAImB,CAAAA,cAAc,CAAGJ,cAAc,CAACK,KAAf,CAAqBvB,aAArB,CAArB,CACA,GAAIwB,CAAAA,mBAAmB,CAAG,CAA1B,CACA,GAAIC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,EAAW,CAC7B,GAAIC,CAAAA,YAAY,CAAGC,WAAW,EAA9B,CACA;AACA,GAAIC,CAAAA,OAAO,CAAGD,WAAW,IAAM,EAA/B,CACA,MAAOD,CAAAA,YAAY,CAAGE,OAAtB,CAEA,QAASD,CAAAA,WAAT,EAAuB,CACrB,MAAOH,CAAAA,mBAAmB,CAAGF,cAAc,CAACO,MAArC,CACHP,cAAc,CAACE,mBAAmB,EAApB,CADX,CACqCM,SAD5C,CAED,CACF,CAVD,CAYA;AACA,GAAIC,CAAAA,iBAAiB,CAAG,CAAxB,CAA2BC,mBAAmB,CAAG,CAAjD,CAEA;AACA;AACA;AACA,GAAIC,CAAAA,WAAW,CAAG,IAAlB,CAEAd,kBAAkB,CAACe,WAAnB,CAA+B,SAAUC,OAAV,CAAmB,CAChD,GAAIF,WAAW,GAAK,IAApB,CAA0B,CACxB;AACA;AACA,GAAIF,iBAAiB,CAAGI,OAAO,CAACC,aAAhC,CAA+C,CAC7C;AACAC,kBAAkB,CAACJ,WAAD,CAAcR,aAAa,EAA3B,CAAlB,CACAM,iBAAiB,GACjBC,mBAAmB,CAAG,CAAtB,CACA;AACD,CAND,IAMO,CACL;AACA;AACA;AACA,GAAIM,CAAAA,QAAQ,CAAGhB,cAAc,CAACE,mBAAD,CAA7B,CACA,GAAIe,CAAAA,IAAI,CAAGD,QAAQ,CAACE,MAAT,CAAgB,CAAhB,CAAmBL,OAAO,CAACM,eAAR,CACAT,mBADnB,CAAX,CAEAV,cAAc,CAACE,mBAAD,CAAd,CAAsCc,QAAQ,CAACE,MAAT,CAAgBL,OAAO,CAACM,eAAR,CAClBT,mBADE,CAAtC,CAEAA,mBAAmB,CAAGG,OAAO,CAACM,eAA9B,CACAJ,kBAAkB,CAACJ,WAAD,CAAcM,IAAd,CAAlB,CACA;AACAN,WAAW,CAAGE,OAAd,CACA,OACD,CACF,CACD;AACA;AACA;AACA,MAAOJ,iBAAiB,CAAGI,OAAO,CAACC,aAAnC,CAAkD,CAChDf,IAAI,CAACN,GAAL,CAASU,aAAa,EAAtB,EACAM,iBAAiB,GAClB,CACD,GAAIC,mBAAmB,CAAGG,OAAO,CAACM,eAAlC,CAAmD,CACjD,GAAIH,CAAAA,QAAQ,CAAGhB,cAAc,CAACE,mBAAD,CAA7B,CACAH,IAAI,CAACN,GAAL,CAASuB,QAAQ,CAACE,MAAT,CAAgB,CAAhB,CAAmBL,OAAO,CAACM,eAA3B,CAAT,EACAnB,cAAc,CAACE,mBAAD,CAAd,CAAsCc,QAAQ,CAACE,MAAT,CAAgBL,OAAO,CAACM,eAAxB,CAAtC,CACAT,mBAAmB,CAAGG,OAAO,CAACM,eAA9B,CACD,CACDR,WAAW,CAAGE,OAAd,CACD,CAxCD,CAwCG,IAxCH,EAyCA;AACA,GAAIX,mBAAmB,CAAGF,cAAc,CAACO,MAAzC,CAAiD,CAC/C,GAAII,WAAJ,CAAiB,CACf;AACAI,kBAAkB,CAACJ,WAAD,CAAcR,aAAa,EAA3B,CAAlB,CACD,CACD;AACAJ,IAAI,CAACN,GAAL,CAASO,cAAc,CAACoB,MAAf,CAAsBlB,mBAAtB,EAA2CmB,IAA3C,CAAgD,EAAhD,CAAT,EACD,CAED;AACAxB,kBAAkB,CAACyB,OAAnB,CAA2BC,OAA3B,CAAmC,SAAUC,UAAV,CAAsB,CACvD,GAAIC,CAAAA,OAAO,CAAG5B,kBAAkB,CAAC6B,gBAAnB,CAAoCF,UAApC,CAAd,CACA,GAAIC,OAAO,EAAI,IAAf,CAAqB,CACnB,GAAI3B,aAAa,EAAI,IAArB,CAA2B,CACzB0B,UAAU,CAAG/C,IAAI,CAAC4C,IAAL,CAAUvB,aAAV,CAAyB0B,UAAzB,CAAb,CACD,CACDzB,IAAI,CAAC4B,gBAAL,CAAsBH,UAAtB,CAAkCC,OAAlC,EACD,CACF,CARD,EAUA,MAAO1B,CAAAA,IAAP,CAEA,QAASgB,CAAAA,kBAAT,CAA4BF,OAA5B,CAAqCI,IAArC,CAA2C,CACzC,GAAIJ,OAAO,GAAK,IAAZ,EAAoBA,OAAO,CAACtB,MAAR,GAAmBiB,SAA3C,CAAsD,CACpDT,IAAI,CAACN,GAAL,CAASwB,IAAT,EACD,CAFD,IAEO,CACL,GAAI1B,CAAAA,MAAM,CAAGO,aAAa,CACtBrB,IAAI,CAAC4C,IAAL,CAAUvB,aAAV,CAAyBe,OAAO,CAACtB,MAAjC,CADsB,CAEtBsB,OAAO,CAACtB,MAFZ,CAGAQ,IAAI,CAACN,GAAL,CAAS,GAAIZ,CAAAA,UAAJ,CAAegC,OAAO,CAACe,YAAvB,CACef,OAAO,CAACgB,cADvB,CAEetC,MAFf,CAGe0B,IAHf,CAIeJ,OAAO,CAACrB,IAJvB,CAAT,EAKD,CACF,CACF,CA9GH,CAgHA;AACA;AACA;AACA;AACA;AACA,GACAX,UAAU,CAACiD,SAAX,CAAqBrC,GAArB,CAA2B,QAASsC,CAAAA,cAAT,CAAwBC,MAAxB,CAAgC,CACzD,GAAIC,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAJ,CAA2B,CACzBA,MAAM,CAACT,OAAP,CAAe,SAAUY,KAAV,CAAiB,CAC9B,KAAK1C,GAAL,CAAS0C,KAAT,EACD,CAFD,CAEG,IAFH,EAGD,CAJD,IAKK,IAAIH,MAAM,CAACpD,YAAD,CAAN,EAAwB,MAAOoD,CAAAA,MAAP,GAAkB,QAA9C,CAAwD,CAC3D,GAAIA,MAAJ,CAAY,CACV,KAAK7C,QAAL,CAAciD,IAAd,CAAmBJ,MAAnB,EACD,CACF,CAJI,IAKA,CACH,KAAM,IAAIK,CAAAA,SAAJ,CACJ,8EAAgFL,MAD5E,CAAN,CAGD,CACD,MAAO,KAAP,CACD,CAjBD,CAmBA;AACA;AACA;AACA;AACA;AACA,GACAnD,UAAU,CAACiD,SAAX,CAAqBQ,OAArB,CAA+B,QAASC,CAAAA,kBAAT,CAA4BP,MAA5B,CAAoC,CACjE,GAAIC,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAJ,CAA2B,CACzB,IAAK,GAAIQ,CAAAA,CAAC,CAAGR,MAAM,CAACzB,MAAP,CAAc,CAA3B,CAA8BiC,CAAC,EAAI,CAAnC,CAAsCA,CAAC,EAAvC,CAA2C,CACzC,KAAKF,OAAL,CAAaN,MAAM,CAACQ,CAAD,CAAnB,EACD,CACF,CAJD,IAKK,IAAIR,MAAM,CAACpD,YAAD,CAAN,EAAwB,MAAOoD,CAAAA,MAAP,GAAkB,QAA9C,CAAwD,CAC3D,KAAK7C,QAAL,CAAcsD,OAAd,CAAsBT,MAAtB,EACD,CAFI,IAGA,CACH,KAAM,IAAIK,CAAAA,SAAJ,CACJ,8EAAgFL,MAD5E,CAAN,CAGD,CACD,MAAO,KAAP,CACD,CAfD,CAiBA;AACA;AACA;AACA;AACA;AACA;AACA,GACAnD,UAAU,CAACiD,SAAX,CAAqBY,IAArB,CAA4B,QAASC,CAAAA,eAAT,CAAyBC,GAAzB,CAA8B,CACxD,GAAIT,CAAAA,KAAJ,CACA,IAAK,GAAIK,CAAAA,CAAC,CAAG,CAAR,CAAWK,GAAG,CAAG,KAAK1D,QAAL,CAAcoB,MAApC,CAA4CiC,CAAC,CAAGK,GAAhD,CAAqDL,CAAC,EAAtD,CAA0D,CACxDL,KAAK,CAAG,KAAKhD,QAAL,CAAcqD,CAAd,CAAR,CACA,GAAIL,KAAK,CAACvD,YAAD,CAAT,CAAyB,CACvBuD,KAAK,CAACO,IAAN,CAAWE,GAAX,EACD,CAFD,IAGK,CACH,GAAIT,KAAK,GAAK,EAAd,CAAkB,CAChBS,GAAG,CAACT,KAAD,CAAQ,CAAE5C,MAAM,CAAE,KAAKA,MAAf,CACEF,IAAI,CAAE,KAAKA,IADb,CAEEC,MAAM,CAAE,KAAKA,MAFf,CAGEE,IAAI,CAAE,KAAKA,IAHb,CAAR,CAAH,CAID,CACF,CACF,CACF,CAhBD,CAkBA;AACA;AACA;AACA;AACA;AACA,GACAX,UAAU,CAACiD,SAAX,CAAqBT,IAArB,CAA4B,QAASyB,CAAAA,eAAT,CAAyBC,IAAzB,CAA+B,CACzD,GAAIC,CAAAA,WAAJ,CACA,GAAIR,CAAAA,CAAJ,CACA,GAAIK,CAAAA,GAAG,CAAG,KAAK1D,QAAL,CAAcoB,MAAxB,CACA,GAAIsC,GAAG,CAAG,CAAV,CAAa,CACXG,WAAW,CAAG,EAAd,CACA,IAAKR,CAAC,CAAG,CAAT,CAAYA,CAAC,CAAGK,GAAG,CAAC,CAApB,CAAuBL,CAAC,EAAxB,CAA4B,CAC1BQ,WAAW,CAACZ,IAAZ,CAAiB,KAAKjD,QAAL,CAAcqD,CAAd,CAAjB,EACAQ,WAAW,CAACZ,IAAZ,CAAiBW,IAAjB,EACD,CACDC,WAAW,CAACZ,IAAZ,CAAiB,KAAKjD,QAAL,CAAcqD,CAAd,CAAjB,EACA,KAAKrD,QAAL,CAAgB6D,WAAhB,CACD,CACD,MAAO,KAAP,CACD,CAdD,CAgBA;AACA;AACA;AACA;AACA;AACA;AACA,GACAnE,UAAU,CAACiD,SAAX,CAAqBmB,YAArB,CAAoC,QAASC,CAAAA,uBAAT,CAAiCC,QAAjC,CAA2CC,YAA3C,CAAyD,CAC3F,GAAIC,CAAAA,SAAS,CAAG,KAAKlE,QAAL,CAAc,KAAKA,QAAL,CAAcoB,MAAd,CAAuB,CAArC,CAAhB,CACA,GAAI8C,SAAS,CAACzE,YAAD,CAAb,CAA6B,CAC3ByE,SAAS,CAACJ,YAAV,CAAuBE,QAAvB,CAAiCC,YAAjC,EACD,CAFD,IAGK,IAAI,MAAOC,CAAAA,SAAP,GAAqB,QAAzB,CAAmC,CACtC,KAAKlE,QAAL,CAAc,KAAKA,QAAL,CAAcoB,MAAd,CAAuB,CAArC,EAA0C8C,SAAS,CAACC,OAAV,CAAkBH,QAAlB,CAA4BC,YAA5B,CAA1C,CACD,CAFI,IAGA,CACH,KAAKjE,QAAL,CAAciD,IAAd,CAAmB,GAAGkB,OAAH,CAAWH,QAAX,CAAqBC,YAArB,CAAnB,EACD,CACD,MAAO,KAAP,CACD,CAZD,CAcA;AACA;AACA;AACA;AACA;AACA;AACA,GACAvE,UAAU,CAACiD,SAAX,CAAqBH,gBAArB,CACE,QAAS4B,CAAAA,2BAAT,CAAqCC,WAArC,CAAkDC,cAAlD,CAAkE,CAChE,KAAKrE,cAAL,CAAoBX,IAAI,CAACiF,WAAL,CAAiBF,WAAjB,CAApB,EAAqDC,cAArD,CACD,CAHH,CAKA;AACA;AACA;AACA;AACA;AACA,GACA5E,UAAU,CAACiD,SAAX,CAAqB6B,kBAArB,CACE,QAASC,CAAAA,6BAAT,CAAuChB,GAAvC,CAA4C,CAC1C,IAAK,GAAIJ,CAAAA,CAAC,CAAG,CAAR,CAAWK,GAAG,CAAG,KAAK1D,QAAL,CAAcoB,MAApC,CAA4CiC,CAAC,CAAGK,GAAhD,CAAqDL,CAAC,EAAtD,CAA0D,CACxD,GAAI,KAAKrD,QAAL,CAAcqD,CAAd,EAAiB5D,YAAjB,CAAJ,CAAoC,CAClC,KAAKO,QAAL,CAAcqD,CAAd,EAAiBmB,kBAAjB,CAAoCf,GAApC,EACD,CACF,CAED,GAAItB,CAAAA,OAAO,CAAGuC,MAAM,CAACC,IAAP,CAAY,KAAK1E,cAAjB,CAAd,CACA,IAAK,GAAIoD,CAAAA,CAAC,CAAG,CAAR,CAAWK,GAAG,CAAGvB,OAAO,CAACf,MAA9B,CAAsCiC,CAAC,CAAGK,GAA1C,CAA+CL,CAAC,EAAhD,CAAoD,CAClDI,GAAG,CAACnE,IAAI,CAACsF,aAAL,CAAmBzC,OAAO,CAACkB,CAAD,CAA1B,CAAD,CAAiC,KAAKpD,cAAL,CAAoBkC,OAAO,CAACkB,CAAD,CAA3B,CAAjC,CAAH,CACD,CACF,CAZH,CAcA;AACA;AACA;AACA,GACA3D,UAAU,CAACiD,SAAX,CAAqBkC,QAArB,CAAgC,QAASC,CAAAA,mBAAT,EAA+B,CAC7D,GAAIC,CAAAA,GAAG,CAAG,EAAV,CACA,KAAKxB,IAAL,CAAU,SAAUP,KAAV,CAAiB,CACzB+B,GAAG,EAAI/B,KAAP,CACD,CAFD,EAGA,MAAO+B,CAAAA,GAAP,CACD,CAND,CAQA;AACA;AACA;AACA,GACArF,UAAU,CAACiD,SAAX,CAAqBqC,qBAArB,CAA6C,QAASC,CAAAA,gCAAT,CAA0CC,KAA1C,CAAiD,CAC5F,GAAIC,CAAAA,SAAS,CAAG,CACdrD,IAAI,CAAE,EADQ,CAEd5B,IAAI,CAAE,CAFQ,CAGdC,MAAM,CAAE,CAHM,CAAhB,CAKA,GAAIiF,CAAAA,GAAG,CAAG,GAAIhG,CAAAA,kBAAJ,CAAuB8F,KAAvB,CAAV,CACA,GAAIG,CAAAA,mBAAmB,CAAG,KAA1B,CACA,GAAIC,CAAAA,kBAAkB,CAAG,IAAzB,CACA,GAAIC,CAAAA,gBAAgB,CAAG,IAAvB,CACA,GAAIC,CAAAA,kBAAkB,CAAG,IAAzB,CACA,GAAIC,CAAAA,gBAAgB,CAAG,IAAvB,CACA,KAAKlC,IAAL,CAAU,SAAUP,KAAV,CAAiB0C,QAAjB,CAA2B,CACnCP,SAAS,CAACrD,IAAV,EAAkBkB,KAAlB,CACA,GAAI0C,QAAQ,CAACtF,MAAT,GAAoB,IAApB,EACGsF,QAAQ,CAACxF,IAAT,GAAkB,IADrB,EAEGwF,QAAQ,CAACvF,MAAT,GAAoB,IAF3B,CAEiC,CAC/B,GAAGmF,kBAAkB,GAAKI,QAAQ,CAACtF,MAAhC,EACGmF,gBAAgB,GAAKG,QAAQ,CAACxF,IADjC,EAEGsF,kBAAkB,GAAKE,QAAQ,CAACvF,MAFnC,EAGGsF,gBAAgB,GAAKC,QAAQ,CAACrF,IAHpC,CAG0C,CACxC+E,GAAG,CAACO,UAAJ,CAAe,CACbvF,MAAM,CAAEsF,QAAQ,CAACtF,MADJ,CAEbsF,QAAQ,CAAE,CACRxF,IAAI,CAAEwF,QAAQ,CAACxF,IADP,CAERC,MAAM,CAAEuF,QAAQ,CAACvF,MAFT,CAFG,CAMbgF,SAAS,CAAE,CACTjF,IAAI,CAAEiF,SAAS,CAACjF,IADP,CAETC,MAAM,CAAEgF,SAAS,CAAChF,MAFT,CANE,CAUbE,IAAI,CAAEqF,QAAQ,CAACrF,IAVF,CAAf,EAYD,CACDiF,kBAAkB,CAAGI,QAAQ,CAACtF,MAA9B,CACAmF,gBAAgB,CAAGG,QAAQ,CAACxF,IAA5B,CACAsF,kBAAkB,CAAGE,QAAQ,CAACvF,MAA9B,CACAsF,gBAAgB,CAAGC,QAAQ,CAACrF,IAA5B,CACAgF,mBAAmB,CAAG,IAAtB,CACD,CAzBD,IAyBO,IAAIA,mBAAJ,CAAyB,CAC9BD,GAAG,CAACO,UAAJ,CAAe,CACbR,SAAS,CAAE,CACTjF,IAAI,CAAEiF,SAAS,CAACjF,IADP,CAETC,MAAM,CAAEgF,SAAS,CAAChF,MAFT,CADE,CAAf,EAMAmF,kBAAkB,CAAG,IAArB,CACAD,mBAAmB,CAAG,KAAtB,CACD,CACD,IAAK,GAAIO,CAAAA,GAAG,CAAG,CAAV,CAAaxE,MAAM,CAAG4B,KAAK,CAAC5B,MAAjC,CAAyCwE,GAAG,CAAGxE,MAA/C,CAAuDwE,GAAG,EAA1D,CAA8D,CAC5D,GAAI5C,KAAK,CAAC6C,UAAN,CAAiBD,GAAjB,IAA0BpG,YAA9B,CAA4C,CAC1C2F,SAAS,CAACjF,IAAV,GACAiF,SAAS,CAAChF,MAAV,CAAmB,CAAnB,CACA;AACA,GAAIyF,GAAG,CAAG,CAAN,GAAYxE,MAAhB,CAAwB,CACtBkE,kBAAkB,CAAG,IAArB,CACAD,mBAAmB,CAAG,KAAtB,CACD,CAHD,IAGO,IAAIA,mBAAJ,CAAyB,CAC9BD,GAAG,CAACO,UAAJ,CAAe,CACbvF,MAAM,CAAEsF,QAAQ,CAACtF,MADJ,CAEbsF,QAAQ,CAAE,CACRxF,IAAI,CAAEwF,QAAQ,CAACxF,IADP,CAERC,MAAM,CAAEuF,QAAQ,CAACvF,MAFT,CAFG,CAMbgF,SAAS,CAAE,CACTjF,IAAI,CAAEiF,SAAS,CAACjF,IADP,CAETC,MAAM,CAAEgF,SAAS,CAAChF,MAFT,CANE,CAUbE,IAAI,CAAEqF,QAAQ,CAACrF,IAVF,CAAf,EAYD,CACF,CArBD,IAqBO,CACL8E,SAAS,CAAChF,MAAV,GACD,CACF,CACF,CA/DD,EAgEA,KAAKqE,kBAAL,CAAwB,SAAUnC,UAAV,CAAsByD,aAAtB,CAAqC,CAC3DV,GAAG,CAAC5C,gBAAJ,CAAqBH,UAArB,CAAiCyD,aAAjC,EACD,CAFD,EAIA,MAAO,CAAEhE,IAAI,CAAEqD,SAAS,CAACrD,IAAlB,CAAwBsD,GAAG,CAAEA,GAA7B,CAAP,CACD,CAjFD,CAmFAW,OAAO,CAACrG,UAAR,CAAqBA,UAArB"},"metadata":{},"sourceType":"script"}