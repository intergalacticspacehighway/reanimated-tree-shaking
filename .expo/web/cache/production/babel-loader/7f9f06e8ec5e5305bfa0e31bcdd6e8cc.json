{"ast":null,"code":"\"use strict\";var _toConsumableArray=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray\");function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.createGeneratedHeaderComment=createGeneratedHeaderComment;exports.createHash=createHash;exports.mergeContents=mergeContents;exports.removeContents=removeContents;exports.removeGeneratedContents=removeGeneratedContents;function _crypto(){var data=_interopRequireDefault(require(\"crypto\"));_crypto=function _crypto(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * Get line indexes for the generated section of a file.\n *\n * @param src\n */function getGeneratedSectionIndexes(src,tag){var contents=src.split('\\n');var start=contents.findIndex(function(line){return line.includes(\"@generated begin \".concat(tag));});var end=contents.findIndex(function(line){return line.includes(\"@generated end \".concat(tag));});return{contents:contents,start:start,end:end};}/**\n * Merge the contents of two files together and add a generated header.\n *\n * @param src contents of the original file\n * @param newSrc new contents to merge into the original file\n * @param identifier used to update and remove merges\n * @param anchor regex to where the merge should begin\n * @param offset line offset to start merging at (<1 for behind the anchor)\n * @param comment comment style `//` or `#`\n */function mergeContents(_ref){var src=_ref.src,newSrc=_ref.newSrc,tag=_ref.tag,anchor=_ref.anchor,offset=_ref.offset,comment=_ref.comment;var header=createGeneratedHeaderComment(newSrc,tag,comment);if(!src.includes(header)){// Ensure the old generated contents are removed.\nvar sanitizedTarget=removeGeneratedContents(src,tag);return{contents:addLines(sanitizedTarget!==null&&sanitizedTarget!==void 0?sanitizedTarget:src,anchor,offset,[header].concat(_toConsumableArray(newSrc.split('\\n')),[\"\".concat(comment,\" @generated end \").concat(tag)])),didMerge:true,didClear:!!sanitizedTarget};}return{contents:src,didClear:false,didMerge:false};}function removeContents(_ref2){var src=_ref2.src,tag=_ref2.tag;// Ensure the old generated contents are removed.\nvar sanitizedTarget=removeGeneratedContents(src,tag);return{contents:sanitizedTarget!==null&&sanitizedTarget!==void 0?sanitizedTarget:src,didMerge:false,didClear:!!sanitizedTarget};}function addLines(content,find,offset,toAdd){var lines=content.split('\\n');var lineIndex=lines.findIndex(function(line){return line.match(find);});if(lineIndex<0){var error=new Error(\"Failed to match \\\"\".concat(find,\"\\\" in contents:\\n\").concat(content));// @ts-ignore\nerror.code='ERR_NO_MATCH';throw error;}var _iterator=_createForOfIteratorHelper(toAdd),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var newLine=_step.value;lines.splice(lineIndex+offset,0,newLine);lineIndex++;}}catch(err){_iterator.e(err);}finally{_iterator.f();}return lines.join('\\n');}/**\n * Removes the generated section from a file, returns null when nothing can be removed.\n * This sways heavily towards not removing lines unless it's certain that modifications were not made manually.\n *\n * @param src\n */function removeGeneratedContents(src,tag){var _getGeneratedSectionI=getGeneratedSectionIndexes(src,tag),contents=_getGeneratedSectionI.contents,start=_getGeneratedSectionI.start,end=_getGeneratedSectionI.end;if(start>-1&&end>-1&&start<end){contents.splice(start,end-start+1);// TODO: We could in theory check that the contents we're removing match the hash used in the header,\n// this would ensure that we don't accidentally remove lines that someone added or removed from the generated section.\nreturn contents.join('\\n');}return null;}function createGeneratedHeaderComment(contents,tag,comment){var hashKey=createHash(contents);// Everything after the `${tag} ` is unversioned and can be freely modified without breaking changes.\nreturn\"\".concat(comment,\" @generated begin \").concat(tag,\" - expo prebuild (DO NOT MODIFY) \").concat(hashKey);}function createHash(src){// this doesn't need to be secure, the shorter the better.\nvar hash=_crypto()[\"default\"].createHash('sha1').update(src).digest('hex');return\"sync-\".concat(hash);}","map":{"version":3,"sources":["../../src/utils/generateCode.ts"],"names":["contents","src","start","line","end","comment","header","createGeneratedHeaderComment","sanitizedTarget","removeGeneratedContents","addLines","newSrc","didMerge","didClear","tag","lines","content","lineIndex","error","find","getGeneratedSectionIndexes","hashKey","createHash","hash","crypto"],"mappings":"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","sourcesContent":["/**\n * Get line indexes for the generated section of a file.\n *\n * @param src\n */\nimport crypto from 'crypto';\n\nfunction getGeneratedSectionIndexes(\n  src: string,\n  tag: string\n): { contents: string[]; start: number; end: number } {\n  const contents = src.split('\\n');\n  const start = contents.findIndex(line => line.includes(`@generated begin ${tag}`));\n  const end = contents.findIndex(line => line.includes(`@generated end ${tag}`));\n\n  return { contents, start, end };\n}\n\nexport type MergeResults = {\n  contents: string;\n  didClear: boolean;\n  didMerge: boolean;\n};\n\n/**\n * Merge the contents of two files together and add a generated header.\n *\n * @param src contents of the original file\n * @param newSrc new contents to merge into the original file\n * @param identifier used to update and remove merges\n * @param anchor regex to where the merge should begin\n * @param offset line offset to start merging at (<1 for behind the anchor)\n * @param comment comment style `//` or `#`\n */\nexport function mergeContents({\n  src,\n  newSrc,\n  tag,\n  anchor,\n  offset,\n  comment,\n}: {\n  src: string;\n  newSrc: string;\n  tag: string;\n  anchor: string | RegExp;\n  offset: number;\n  comment: string;\n}): MergeResults {\n  const header = createGeneratedHeaderComment(newSrc, tag, comment);\n  if (!src.includes(header)) {\n    // Ensure the old generated contents are removed.\n    const sanitizedTarget = removeGeneratedContents(src, tag);\n    return {\n      contents: addLines(sanitizedTarget ?? src, anchor, offset, [\n        header,\n        ...newSrc.split('\\n'),\n        `${comment} @generated end ${tag}`,\n      ]),\n      didMerge: true,\n      didClear: !!sanitizedTarget,\n    };\n  }\n  return { contents: src, didClear: false, didMerge: false };\n}\n\nexport function removeContents({ src, tag }: { src: string; tag: string }): MergeResults {\n  // Ensure the old generated contents are removed.\n  const sanitizedTarget = removeGeneratedContents(src, tag);\n  return {\n    contents: sanitizedTarget ?? src,\n    didMerge: false,\n    didClear: !!sanitizedTarget,\n  };\n}\n\nfunction addLines(content: string, find: string | RegExp, offset: number, toAdd: string[]) {\n  const lines = content.split('\\n');\n\n  let lineIndex = lines.findIndex(line => line.match(find));\n  if (lineIndex < 0) {\n    const error = new Error(`Failed to match \"${find}\" in contents:\\n${content}`);\n    // @ts-ignore\n    error.code = 'ERR_NO_MATCH';\n    throw error;\n  }\n  for (const newLine of toAdd) {\n    lines.splice(lineIndex + offset, 0, newLine);\n    lineIndex++;\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Removes the generated section from a file, returns null when nothing can be removed.\n * This sways heavily towards not removing lines unless it's certain that modifications were not made manually.\n *\n * @param src\n */\nexport function removeGeneratedContents(src: string, tag: string): string | null {\n  const { contents, start, end } = getGeneratedSectionIndexes(src, tag);\n  if (start > -1 && end > -1 && start < end) {\n    contents.splice(start, end - start + 1);\n    // TODO: We could in theory check that the contents we're removing match the hash used in the header,\n    // this would ensure that we don't accidentally remove lines that someone added or removed from the generated section.\n    return contents.join('\\n');\n  }\n  return null;\n}\n\nexport function createGeneratedHeaderComment(\n  contents: string,\n  tag: string,\n  comment: string\n): string {\n  const hashKey = createHash(contents);\n\n  // Everything after the `${tag} ` is unversioned and can be freely modified without breaking changes.\n  return `${comment} @generated begin ${tag} - expo prebuild (DO NOT MODIFY) ${hashKey}`;\n}\n\nexport function createHash(src: string): string {\n  // this doesn't need to be secure, the shorter the better.\n  const hash = crypto.createHash('sha1').update(src).digest('hex');\n  return `sync-${hash}`;\n}\n"]},"metadata":{},"sourceType":"script"}