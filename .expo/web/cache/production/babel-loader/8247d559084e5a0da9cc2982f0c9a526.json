{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});/**\n * Converts absolute paths to relative paths for testing purposes.\n *\n * @param initial\n * @param transformString\n * @internal\n */function normalizePaths(initial,transformString){if(initial==null){return initial;}else if(initial instanceof RegExp){return initial;}else if(typeof initial==='string'){return transformString(initial);}else if(Array.isArray(initial)){return initial.map(function(value){return normalizePaths(value,transformString);});}else if(typeof initial==='object'){var result={};for(var _i=0,_Object$keys=Object.keys(initial);_i<_Object$keys.length;_i++){var prop=_Object$keys[_i];result[prop]=normalizePaths(initial[prop],transformString);}return result;}else{return initial;}}exports[\"default\"]=normalizePaths;","map":{"version":3,"sources":["../../src/utils/normalizePaths.ts"],"names":[],"mappings":"sEAAA;;;;;;AAMG,GACH,QAAwB,CAAA,cAAxB,CACE,OADF,CAEE,eAFF,CAE4C,CAE1C,GAAI,OAAO,EAAI,IAAf,CAAqB,CACnB,MAAO,CAAA,OAAP,CACD,CAFD,IAEO,IAAI,OAAO,WAAY,CAAA,MAAvB,CAA+B,CACpC,MAAO,CAAA,OAAP,CACD,CAFM,IAEA,IAAI,MAAO,CAAA,OAAP,GAAmB,QAAvB,CAAiC,CACtC,MAAO,CAAA,eAAe,CAAC,OAAD,CAAtB,CACD,CAFM,IAEA,IAAI,KAAK,CAAC,OAAN,CAAc,OAAd,CAAJ,CAA4B,CACjC,MAAO,CAAA,OAAO,CAAC,GAAR,CAAY,SAAA,KAAK,QAAI,CAAA,cAAc,CAAC,KAAD,CAAQ,eAAR,CAAlB,EAAjB,CAAP,CACD,CAFM,IAEA,IAAI,MAAO,CAAA,OAAP,GAAmB,QAAvB,CAAiC,CACtC,GAAM,CAAA,MAAM,CAA2B,EAAvC,CACA,0BAAmB,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAnB,6BAAyC,CAApC,GAAM,CAAA,IAAI,iBAAV,CACH,MAAM,CAAC,IAAD,CAAN,CAAe,cAAc,CAAC,OAAO,CAAC,IAAD,CAAR,CAAgB,eAAhB,CAA7B,CACD,CACD,MAAO,CAAA,MAAP,CACD,CANM,IAMA,CACL,MAAO,CAAA,OAAP,CACD,CACF,CArBD,OAAA,WAAA,CAAA,cAAA","sourcesContent":["/**\n * Converts absolute paths to relative paths for testing purposes.\n *\n * @param initial\n * @param transformString\n * @internal\n */\nexport default function normalizePaths(\n  initial: any,\n  transformString: (value: string) => string\n): any {\n  if (initial == null) {\n    return initial;\n  } else if (initial instanceof RegExp) {\n    return initial;\n  } else if (typeof initial === 'string') {\n    return transformString(initial);\n  } else if (Array.isArray(initial)) {\n    return initial.map(value => normalizePaths(value, transformString));\n  } else if (typeof initial === 'object') {\n    const result: { [key: string]: any } = {};\n    for (const prop of Object.keys(initial)) {\n      result[prop] = normalizePaths(initial[prop], transformString);\n    }\n    return result;\n  } else {\n    return initial;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}