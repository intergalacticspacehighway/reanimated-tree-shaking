{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */'use strict';exports.__esModule=true;exports.computeWindowedRenderLimits=computeWindowedRenderLimits;exports.elementsThatOverlapOffsets=elementsThatOverlapOffsets;exports.newRangeCount=newRangeCount;exports[\"default\"]=void 0;var _invariant=_interopRequireDefault(require(\"fbjs/lib/invariant\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */function elementsThatOverlapOffsets(offsets,itemCount,getFrameMetrics){var out=[];var outLength=0;for(var ii=0;ii<itemCount;ii++){var frame=getFrameMetrics(ii);var trailingOffset=frame.offset+frame.length;for(var kk=0;kk<offsets.length;kk++){if(out[kk]==null&&trailingOffset>=offsets[kk]){out[kk]=ii;outLength++;if(kk===offsets.length-1){(0,_invariant[\"default\"])(outLength===offsets.length,'bad offsets input, should be in increasing order: %s',JSON.stringify(offsets));return out;}}}}return out;}/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */function newRangeCount(prev,next){return next.last-next.first+1-Math.max(0,1+Math.min(next.last,prev.last)-Math.max(next.first,prev.first));}/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */function computeWindowedRenderLimits(props,prev,getFrameMetricsApprox,scrollMetrics){var data=props.data,getItemCount=props.getItemCount,maxToRenderPerBatch=props.maxToRenderPerBatch,windowSize=props.windowSize;var itemCount=getItemCount(data);if(itemCount===0){return prev;}var offset=scrollMetrics.offset,velocity=scrollMetrics.velocity,visibleLength=scrollMetrics.visibleLength;// Start with visible area, then compute maximum overscan region by expanding from there, biased\n// in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n// too.\nvar visibleBegin=Math.max(0,offset);var visibleEnd=visibleBegin+visibleLength;var overscanLength=(windowSize-1)*visibleLength;// Considering velocity seems to introduce more churn than it's worth.\nvar leadFactor=0.5;// Math.max(0, Math.min(1, velocity / 25 + 0.5));\nvar fillPreference=velocity>1?'after':velocity<-1?'before':'none';var overscanBegin=Math.max(0,visibleBegin-(1-leadFactor)*overscanLength);var overscanEnd=Math.max(0,visibleEnd+leadFactor*overscanLength);var lastItemOffset=getFrameMetricsApprox(itemCount-1).offset;if(lastItemOffset<overscanBegin){// Entire list is before our overscan window\nreturn{first:Math.max(0,itemCount-1-maxToRenderPerBatch),last:itemCount-1};}// Find the indices that correspond to the items at the render boundaries we're targeting.\nvar _elementsThatOverlapO=elementsThatOverlapOffsets([overscanBegin,visibleBegin,visibleEnd,overscanEnd],props.getItemCount(props.data),getFrameMetricsApprox),overscanFirst=_elementsThatOverlapO[0],first=_elementsThatOverlapO[1],last=_elementsThatOverlapO[2],overscanLast=_elementsThatOverlapO[3];overscanFirst=overscanFirst==null?0:overscanFirst;first=first==null?Math.max(0,overscanFirst):first;overscanLast=overscanLast==null?itemCount-1:overscanLast;last=last==null?Math.min(overscanLast,first+maxToRenderPerBatch-1):last;var visible={first:first,last:last};// We want to limit the number of new cells we're rendering per batch so that we can fill the\n// content on the screen quickly. If we rendered the entire overscan window at once, the user\n// could be staring at white space for a long time waiting for a bunch of offscreen content to\n// render.\nvar newCellCount=newRangeCount(prev,visible);while(true){if(first<=overscanFirst&&last>=overscanLast){// If we fill the entire overscan range, we're done.\nbreak;}var maxNewCells=newCellCount>=maxToRenderPerBatch;var firstWillAddMore=first<=prev.first||first>prev.last;var firstShouldIncrement=first>overscanFirst&&(!maxNewCells||!firstWillAddMore);var lastWillAddMore=last>=prev.last||last<prev.first;var lastShouldIncrement=last<overscanLast&&(!maxNewCells||!lastWillAddMore);if(maxNewCells&&!firstShouldIncrement&&!lastShouldIncrement){// We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n// without rendering new items. This let's us preserve as many already rendered items as\n// possible, reducing render churn and keeping the rendered overscan range as large as\n// possible.\nbreak;}if(firstShouldIncrement&&!(fillPreference==='after'&&lastShouldIncrement&&lastWillAddMore)){if(firstWillAddMore){newCellCount++;}first--;}if(lastShouldIncrement&&!(fillPreference==='before'&&firstShouldIncrement&&firstWillAddMore)){if(lastWillAddMore){newCellCount++;}last++;}}if(!(last>=first&&first>=0&&last<itemCount&&first>=overscanFirst&&last<=overscanLast&&first<=visible.first&&last>=visible.last)){throw new Error('Bad window calculation '+JSON.stringify({first:first,last:last,itemCount:itemCount,overscanFirst:overscanFirst,overscanLast:overscanLast,visible:visible}));}return{first:first,last:last};}var VirtualizeUtils={computeWindowedRenderLimits:computeWindowedRenderLimits,elementsThatOverlapOffsets:elementsThatOverlapOffsets,newRangeCount:newRangeCount};var _default=VirtualizeUtils;exports[\"default\"]=_default;","map":{"version":3,"names":["exports","__esModule","computeWindowedRenderLimits","elementsThatOverlapOffsets","newRangeCount","_invariant","_interopRequireDefault","require","obj","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","prev","next","last","first","Math","max","min","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils","_default"],"sources":["/Users/fernandorojo/Developer/messing/rea-tree/node_modules/react-native-web/dist/cjs/vendor/react-native/VirtualizeUtils/index.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.newRangeCount = newRangeCount;\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          (0, _invariant.default)(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n      getItemCount = props.getItemCount,\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\n      windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nvar _default = VirtualizeUtils;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}