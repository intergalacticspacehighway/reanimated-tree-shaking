{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.getDynamicConfig=getDynamicConfig;exports.getStaticConfig=getStaticConfig;function _jsonFile(){var data=_interopRequireDefault(require(\"@expo/json-file\"));_jsonFile=function _jsonFile(){return data;};return data;}function _fs(){var data=require(\"fs\");_fs=function _fs(){return data;};return data;}function _Errors(){var data=require(\"./Errors\");_Errors=function _Errors(){return data;};return data;}function _evalConfig(){var data=require(\"./evalConfig\");_evalConfig=function _evalConfig(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}// We cannot use async config resolution right now because Next.js doesn't support async configs.\n// If they don't add support for async Webpack configs then we may need to pull support for Next.js.\nfunction readConfigFile(configFile,context){// If the file doesn't exist then we should skip it and continue searching.\nif(!(0,_fs().existsSync)(configFile)){return null;}try{return(0,_evalConfig().evalConfig)(configFile,context);}catch(error){// @ts-ignore\nerror.isConfigError=true;error.message=\"Error reading Expo config at \".concat(configFile,\":\\n\\n\").concat(error.message);throw error;}}function getDynamicConfig(configPath,request){var config=readConfigFile(configPath,request);if(config){// The config must be serialized and evaluated ahead of time so the spawned process can send it over.\nreturn config;}// TODO: It seems this is only thrown if the file cannot be found (which may never happen).\n// If so we should throw a more helpful error.\nthrow new(_Errors().ConfigError)(\"Failed to read config at: \".concat(configPath),'INVALID_CONFIG');}function getStaticConfig(configPath){var config=_jsonFile()[\"default\"].read(configPath,{json5:true});if(config){return config;}throw new(_Errors().ConfigError)(\"Failed to read config at: \".concat(configPath),'INVALID_CONFIG');}","map":{"version":3,"sources":["../src/getConfig.ts"],"names":["error","configFile","config","readConfigFile","ConfigError","json5"],"mappings":"wJAAA,QAAA,CAAA,SAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,sBAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,CAAA,SAAA,CAAA,oBAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CACA,QAAA,CAAA,GAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA,GAAA,CAAA,cAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAGA,QAAA,CAAA,OAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAA,UAAA,CAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CACA,QAAA,CAAA,WAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA,WAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,C,qFAEA;AACA;AACA,QAAA,CAAA,cAAA,CAAA,UAAA,CAAA,OAAA,CAAiG,CAC/F;AACA,GAAI,CAAC,CAAA,EAAA,GAAA,GAAA,UAAA,EAAL,UAAK,CAAL,CAA6B,CAC3B,MAAA,KAAA,CACD,CACD,GAAI,CACF,MAAO,CAAA,EAAA,WAAA,GAAA,UAAA,EAAA,UAAA,CAAP,OAAO,CAAP,CADF,CAEE,MAAA,KAAA,CAAmB,CACnB;AACAA,KAAK,CAALA,aAAAA,CAAAA,IAAAA,CACAA,KAAK,CAALA,OAAAA,wCAAgDC,UAAhDD,iBAAkEA,KAAK,CAAvEA,OAAAA,EACA,KAAA,CAAA,KAAA,CACD,CACF,CAEM,QAAA,CAAA,gBAAA,CAAA,UAAA,CAAA,OAAA,CAA4F,CACjG,GAAME,CAAAA,MAAM,CAAGC,cAAc,CAAA,UAAA,CAA7B,OAA6B,CAA7B,CACA,GAAA,MAAA,CAAY,CACV;AACA,MAAA,CAAA,MAAA,CAJ+F,CAMjG;AACA;AACA,KAAM,KAAIC,OAAAA,GAAJ,WAAA,sCAAA,UAAA,EAAN,gBAAM,CAAN,CACD,CAEM,QAAA,CAAA,eAAA,CAAA,UAAA,CAAyE,CAC9E,GAAMF,CAAAA,MAAM,CAAG,SAAA,aAAA,CAAA,IAAA,CAAA,UAAA,CAA0B,CAAEG,KAAK,CAAE,IAAT,CAA1B,CAAf,CACA,GAAA,MAAA,CAAY,CACV,MAAA,CAAA,MAAA,CACD,CACD,KAAM,KAAID,OAAAA,GAAJ,WAAA,sCAAA,UAAA,EAAN,gBAAM,CAAN,CACD","sourcesContent":["import JsonFile from '@expo/json-file';\nimport { existsSync } from 'fs';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { DynamicConfigResults, evalConfig } from './evalConfig';\n\n// We cannot use async config resolution right now because Next.js doesn't support async configs.\n// If they don't add support for async Webpack configs then we may need to pull support for Next.js.\nfunction readConfigFile(configFile: string, context: ConfigContext): null | DynamicConfigResults {\n  // If the file doesn't exist then we should skip it and continue searching.\n  if (!existsSync(configFile)) {\n    return null;\n  }\n  try {\n    return evalConfig(configFile, context);\n  } catch (error: any) {\n    // @ts-ignore\n    error.isConfigError = true;\n    error.message = `Error reading Expo config at ${configFile}:\\n\\n${error.message}`;\n    throw error;\n  }\n}\n\nexport function getDynamicConfig(configPath: string, request: ConfigContext): DynamicConfigResults {\n  const config = readConfigFile(configPath, request);\n  if (config) {\n    // The config must be serialized and evaluated ahead of time so the spawned process can send it over.\n    return config;\n  }\n  // TODO: It seems this is only thrown if the file cannot be found (which may never happen).\n  // If so we should throw a more helpful error.\n  throw new ConfigError(`Failed to read config at: ${configPath}`, 'INVALID_CONFIG');\n}\n\nexport function getStaticConfig(configPath: string): AppJSONConfig | ExpoConfig {\n  const config = JsonFile.read(configPath, { json5: true });\n  if (config) {\n    return config as any;\n  }\n  throw new ConfigError(`Failed to read config at: ${configPath}`, 'INVALID_CONFIG');\n}\n"]},"metadata":{},"sourceType":"script"}