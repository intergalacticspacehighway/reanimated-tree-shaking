{"ast":null,"code":"\"use strict\";var _toConsumableArray=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/toConsumableArray\");var __rest=this&&this.__rest||function(s,e){var t={};for(var p in s){if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];}if(s!=null&&typeof Object.getOwnPropertySymbols===\"function\")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0)t[p[i]]=s[p[i]];}return t;};var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});var cross_spawn_1=__importDefault(require(\"cross-spawn\"));function spawnAsync(command,args){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var fakeErr=new Error('fake error just to preserve stacktrace');var previousStack=fakeErr.stack&&fakeErr.stack.split('\\n').splice(1);var previousStackString=previousStack&&['    ...'].concat(_toConsumableArray(previousStack)).join('\\n');var child;var promise=new Promise(function(resolve,reject){var ignoreStdio=options.ignoreStdio,nodeOptions=__rest(options,[\"ignoreStdio\"]);// @ts-ignore: cross-spawn declares \"args\" to be a regular array instead of a read-only one\nchild=cross_spawn_1[\"default\"](command,args,nodeOptions);var stdout='';var stderr='';if(!ignoreStdio){if(child.stdout){child.stdout.on('data',function(data){stdout+=data;});}if(child.stderr){child.stderr.on('data',function(data){stderr+=data;});}}var completionListener=function completionListener(code,signal){child.removeListener('error',errorListener);var result={pid:child.pid,output:[stdout,stderr],stdout:stdout,stderr:stderr,status:code,signal:signal};if(code!==0){var error=signal?new Error(\"\".concat(command,\" exited with signal: \").concat(signal)):new Error(\"\".concat(command,\" exited with non-zero code: \").concat(code));if(error.stack&&previousStackString){error.stack+=\"\\n\".concat(previousStackString);}Object.assign(error,result);reject(error);}else{resolve(result);}};var errorListener=function errorListener(error){if(ignoreStdio){child.removeListener('exit',completionListener);}else{child.removeListener('close',completionListener);}Object.assign(error,{pid:child.pid,output:[stdout,stderr],stdout:stdout,stderr:stderr,status:null,signal:null});reject(error);};if(ignoreStdio){child.once('exit',completionListener);}else{child.once('close',completionListener);}child.once('error',errorListener);});// @ts-ignore: TypeScript isn't aware the Promise constructor argument runs synchronously and\n// thinks `child` is not yet defined\npromise.child=child;return promise;}exports[\"default\"]=spawnAsync;","map":{"version":3,"sources":["../src/spawnAsync.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChildProcess, SpawnOptions as NodeSpawnOptions } from 'child_process';\nimport spawn from 'cross-spawn';\n\nexport interface SpawnOptions extends NodeSpawnOptions {\n  ignoreStdio?: boolean;\n}\n\nexport interface SpawnPromise<T> extends Promise<T> {\n  child: ChildProcess;\n}\n\nexport interface SpawnResult {\n  pid: number;\n  output: string[];\n  stdout: string;\n  stderr: string;\n  status: number | null;\n  signal: string | null;\n}\n\nexport default function spawnAsync(\n  command: string,\n  args?: ReadonlyArray<string>,\n  options: SpawnOptions = {}\n): SpawnPromise<SpawnResult> {\n  const fakeErr = new Error('fake error just to preserve stacktrace');\n  const previousStack = fakeErr.stack && fakeErr.stack.split('\\n').splice(1);\n  const previousStackString = previousStack && ['    ...', ...previousStack].join('\\n');\n\n  let child: ChildProcess;\n  let promise = new Promise((resolve, reject) => {\n    let { ignoreStdio, ...nodeOptions } = options;\n    // @ts-ignore: cross-spawn declares \"args\" to be a regular array instead of a read-only one\n    child = spawn(command, args, nodeOptions);\n    let stdout = '';\n    let stderr = '';\n\n    if (!ignoreStdio) {\n      if (child.stdout) {\n        child.stdout.on('data', data => {\n          stdout += data;\n        });\n      }\n\n      if (child.stderr) {\n        child.stderr.on('data', data => {\n          stderr += data;\n        });\n      }\n    }\n\n    let completionListener = (code: number | null, signal: string | null) => {\n      child.removeListener('error', errorListener);\n      let result: SpawnResult = {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout,\n        stderr,\n        status: code,\n        signal,\n      };\n      if (code !== 0) {\n        let error = signal\n          ? new Error(`${command} exited with signal: ${signal}`)\n          : new Error(`${command} exited with non-zero code: ${code}`);\n        if (error.stack && previousStackString) {\n          error.stack += `\\n${previousStackString}`;\n        }\n        Object.assign(error, result);\n        reject(error);\n      } else {\n        resolve(result);\n      }\n    };\n\n    let errorListener = (error: Error) => {\n      if (ignoreStdio) {\n        child.removeListener('exit', completionListener);\n      } else {\n        child.removeListener('close', completionListener);\n      }\n      Object.assign(error, {\n        pid: child.pid,\n        output: [stdout, stderr],\n        stdout,\n        stderr,\n        status: null,\n        signal: null,\n      });\n      reject(error);\n    };\n\n    if (ignoreStdio) {\n      child.once('exit', completionListener);\n    } else {\n      child.once('close', completionListener);\n    }\n    child.once('error', errorListener);\n  }) as SpawnPromise<SpawnResult>;\n  // @ts-ignore: TypeScript isn't aware the Promise constructor argument runs synchronously and\n  // thinks `child` is not yet defined\n  promise.child = child;\n  return promise;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}