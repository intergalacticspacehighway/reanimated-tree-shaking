{"ast":null,"code":"\"use strict\";var _slicedToArray=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray\");var _regeneratorRuntime=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/regenerator\");var _defineProperty=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty\");var _objectWithoutProperties=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/objectWithoutProperties\");var _asyncToGenerator=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator\");var _excluded=[\"modRequest\"],_excluded2=[\"nextMod\"],_excluded3=[\"modRequest\",\"modResults\"];function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.withBaseMod=withBaseMod;exports.withMod=withMod;function _chalk(){var data=_interopRequireDefault(require(\"chalk\"));_chalk=function _chalk(){return data;};return data;}function _getenv(){var data=require(\"getenv\");_getenv=function _getenv(){return data;};return data;}function _errors(){var data=require(\"../utils/errors\");_errors=function _errors(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}var EXPO_DEBUG=(0,_getenv().boolish)('EXPO_DEBUG',false);/**\n * Plugin to intercept execution of a given `mod` with the given `action`.\n * If an action was already set on the given `config` config for `mod`, then it\n * will be provided to the `action` as `nextMod` when it's evaluated, otherwise\n * `nextMod` will be an identity function.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to intercept\n * @param skipEmptyMod should skip running the action if there is no existing mod to intercept\n * @param saveToInternal should save the results to `_internal.modResults`, only enable this when the results are pure JSON.\n * @param isProvider should provide data up to the other mods.\n * @param action method to run on the mod when the config is compiled\n */function withBaseMod(config,_ref2){var platform=_ref2.platform,mod=_ref2.mod,action=_ref2.action,skipEmptyMod=_ref2.skipEmptyMod,isProvider=_ref2.isProvider,isIntrospective=_ref2.isIntrospective,saveToInternal=_ref2.saveToInternal;var _config$_internal$isD,_config$_internal;if(!config.mods){config.mods={};}if(!config.mods[platform]){config.mods[platform]={};}var interceptedMod=config.mods[platform][mod];// No existing mod to intercept\nif(!interceptedMod){if(skipEmptyMod){// Skip running the action\nreturn config;}// Use a noop mod and continue\nvar noopMod=function noopMod(config){return config;};interceptedMod=noopMod;}// Create a stack trace for debugging ahead of time\nvar debugTrace='';// Use the possibly user defined value. Otherwise fallback to the env variable.\n// We support the env variable because user mods won't have _internal defined in time.\nvar isDebug=(_config$_internal$isD=(_config$_internal=config._internal)===null||_config$_internal===void 0?void 0:_config$_internal.isDebug)!==null&&_config$_internal$isD!==void 0?_config$_internal$isD:EXPO_DEBUG;if(isDebug){// Get a stack trace via the Error API\nvar stack=new Error().stack;// Format the stack trace to create the debug log\ndebugTrace=getDebugPluginStackFromStackTrace(stack);var modStack=_chalk()[\"default\"].bold(\"\".concat(platform,\".\").concat(mod));debugTrace=\"\".concat(modStack,\": \").concat(debugTrace);}// Prevent adding multiple providers to a mod.\n// Base mods that provide files ignore any incoming modResults and therefore shouldn't have provider mods as parents.\nif(interceptedMod.isProvider){if(isProvider){throw new(_errors().PluginError)(\"Cannot set provider mod for \\\"\".concat(platform,\".\").concat(mod,\"\\\" because another is already being used.\"),'CONFLICTING_PROVIDER');}else{throw new(_errors().PluginError)(\"Cannot add mod to \\\"\".concat(platform,\".\").concat(mod,\"\\\" because the provider has already been added. Provider must be the last mod added.\"),'INVALID_MOD_ORDER');}}function interceptingMod(_x){return _interceptingMod.apply(this,arguments);}// Ensure this base mod is registered as the provider.\nfunction _interceptingMod(){_interceptingMod=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref3){var modRequest,config,results;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:modRequest=_ref3.modRequest,config=_objectWithoutProperties(_ref3,_excluded);if(isDebug){// In debug mod, log the plugin stack in the order which they were invoked\nconsole.log(debugTrace);}_context.next=4;return action(_objectSpread(_objectSpread({},config),{},{modRequest:_objectSpread(_objectSpread({},modRequest),{},{nextMod:interceptedMod})}));case 4:results=_context.sent;if(saveToInternal){saveToInternalObject(results,platform,mod,results.modResults);}return _context.abrupt(\"return\",results);case 7:case\"end\":return _context.stop();}}},_callee);}));return _interceptingMod.apply(this,arguments);}interceptingMod.isProvider=isProvider;if(isIntrospective){// Register the mode as idempotent so introspection doesn't remove it.\ninterceptingMod.isIntrospective=isIntrospective;}config.mods[platform][mod]=interceptingMod;return config;}function saveToInternalObject(config,platformName,modName,results){if(!config._internal)config._internal={};if(!config._internal.modResults)config._internal.modResults={};if(!config._internal.modResults[platformName])config._internal.modResults[platformName]={};config._internal.modResults[platformName][modName]=results;}function getDebugPluginStackFromStackTrace(stacktrace){if(!stacktrace){return'';}var treeStackLines=[];var _iterator=_createForOfIteratorHelper(stacktrace.split('\\n')),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var line=_step.value;var _line$trim$split=line.trim().split(' '),_line$trim$split2=_slicedToArray(_line$trim$split,2),first=_line$trim$split2[0],second=_line$trim$split2[1];if(first==='at'){treeStackLines.push(second);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}var plugins=treeStackLines.map(function(first){var _ref,_first$match$1$trim,_first$match,_first$match$,_first$match2,_first$match2$;// Match the first part of the stack trace against the plugin naming convention\n// \"with\" followed by a capital letter.\nreturn(_ref=(_first$match$1$trim=first===null||first===void 0?void 0:(_first$match=first.match(/^(\\bwith[A-Z].*?\\b)/))===null||_first$match===void 0?void 0:(_first$match$=_first$match[1])===null||_first$match$===void 0?void 0:_first$match$.trim())!==null&&_first$match$1$trim!==void 0?_first$match$1$trim:first===null||first===void 0?void 0:(_first$match2=first.match(/\\.(\\bwith[A-Z].*?\\b)/))===null||_first$match2===void 0?void 0:(_first$match2$=_first$match2[1])===null||_first$match2$===void 0?void 0:_first$match2$.trim())!==null&&_ref!==void 0?_ref:null;}).filter(Boolean).filter(function(plugin){// redundant as all debug logs are captured in withBaseMod\nreturn!['withMod','withBaseMod','withExtendedMod'].includes(plugin);});var commonPlugins=['withPlugins','withRunOnce','withStaticPlugin'];return plugins.reverse().map(function(pluginName,index){// Base mods indicate a logical section.\nif(pluginName.includes('BaseMod')){pluginName=_chalk()[\"default\"].bold(pluginName);}// highlight dangerous mods\nif(pluginName.toLowerCase().includes('dangerous')){pluginName=_chalk()[\"default\"].red(pluginName);}if(index===0){return _chalk()[\"default\"].blue(pluginName);}else if(commonPlugins.includes(pluginName)){// Common mod names often clutter up the logs, dim them out\nreturn _chalk()[\"default\"].dim(pluginName);}return pluginName;})// Join the results:\n// withAndroidExpoPlugins ➜ withPlugins ➜ withIcons ➜ withDangerousMod ➜ withMod\n.join(' ➜ ');}/**\n * Plugin to extend a mod function in the plugins config.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to extend\n * @param action method to run on the mod when the config is compiled\n */function withMod(config,_ref4){var platform=_ref4.platform,mod=_ref4.mod,_action=_ref4.action;return withBaseMod(config,{platform:platform,mod:mod,isProvider:false,action:function action(_ref5){return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var _ref5$modRequest,nextMod,modRequest,modResults,config,results;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_ref5$modRequest=_ref5.modRequest,nextMod=_ref5$modRequest.nextMod,modRequest=_objectWithoutProperties(_ref5$modRequest,_excluded2),modResults=_ref5.modResults,config=_objectWithoutProperties(_ref5,_excluded3);_context2.next=3;return _action(_objectSpread({modRequest:modRequest,modResults:modResults},config));case 3:results=_context2.sent;return _context2.abrupt(\"return\",nextMod(results));case 5:case\"end\":return _context2.stop();}}},_callee2);}))();}});}","map":{"version":3,"sources":["../../src/plugins/withMod.ts"],"names":["EXPO_DEBUG","saveToInternal","config","interceptedMod","noopMod","debugTrace","isDebug","stack","getDebugPluginStackFromStackTrace","modStack","chalk","platform","PluginError","console","results","action","modRequest","nextMod","saveToInternalObject","interceptingMod","treeStackLines","stacktrace","line","first","plugins","plugin","commonPlugins","pluginName","index","withBaseMod","mod","isProvider","modResults"],"mappings":"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","sourcesContent":["import { ExpoConfig } from '@expo/config-types';\nimport { JSONObject } from '@expo/json-file';\nimport chalk from 'chalk';\nimport { boolish } from 'getenv';\n\nimport { ExportedConfig, ExportedConfigWithProps, Mod, ModPlatform } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\nexport type BaseModOptions = {\n  platform: ModPlatform;\n  mod: string;\n  isProvider?: boolean;\n  skipEmptyMod?: boolean;\n  saveToInternal?: boolean;\n  /**\n   * If the mod supports introspection, and avoids making any filesystem modifications during compilation.\n   * By enabling, this mod, and all of its descendants will be run in introspection mode.\n   * This should only be used for static files like JSON or XML, and not for application files that require regexes,\n   * or complex static files that require other files to be generated like Xcode `.pbxproj`.\n   */\n  isIntrospective?: boolean;\n};\n\n/**\n * Plugin to intercept execution of a given `mod` with the given `action`.\n * If an action was already set on the given `config` config for `mod`, then it\n * will be provided to the `action` as `nextMod` when it's evaluated, otherwise\n * `nextMod` will be an identity function.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to intercept\n * @param skipEmptyMod should skip running the action if there is no existing mod to intercept\n * @param saveToInternal should save the results to `_internal.modResults`, only enable this when the results are pure JSON.\n * @param isProvider should provide data up to the other mods.\n * @param action method to run on the mod when the config is compiled\n */\nexport function withBaseMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n    skipEmptyMod,\n    isProvider,\n    isIntrospective,\n    saveToInternal,\n  }: BaseModOptions & { action: Mod<T> }\n): ExportedConfig {\n  if (!config.mods) {\n    config.mods = {};\n  }\n  if (!config.mods[platform]) {\n    config.mods[platform] = {};\n  }\n\n  let interceptedMod: Mod<T> = (config.mods[platform] as Record<string, any>)[mod];\n\n  // No existing mod to intercept\n  if (!interceptedMod) {\n    if (skipEmptyMod) {\n      // Skip running the action\n      return config;\n    }\n    // Use a noop mod and continue\n    const noopMod: Mod<T> = config => config;\n    interceptedMod = noopMod;\n  }\n\n  // Create a stack trace for debugging ahead of time\n  let debugTrace: string = '';\n  // Use the possibly user defined value. Otherwise fallback to the env variable.\n  // We support the env variable because user mods won't have _internal defined in time.\n  const isDebug = config._internal?.isDebug ?? EXPO_DEBUG;\n  if (isDebug) {\n    // Get a stack trace via the Error API\n    const stack = new Error().stack;\n    // Format the stack trace to create the debug log\n    debugTrace = getDebugPluginStackFromStackTrace(stack);\n    const modStack = chalk.bold(`${platform}.${mod}`);\n\n    debugTrace = `${modStack}: ${debugTrace}`;\n  }\n\n  // Prevent adding multiple providers to a mod.\n  // Base mods that provide files ignore any incoming modResults and therefore shouldn't have provider mods as parents.\n  if (interceptedMod.isProvider) {\n    if (isProvider) {\n      throw new PluginError(\n        `Cannot set provider mod for \"${platform}.${mod}\" because another is already being used.`,\n        'CONFLICTING_PROVIDER'\n      );\n    } else {\n      throw new PluginError(\n        `Cannot add mod to \"${platform}.${mod}\" because the provider has already been added. Provider must be the last mod added.`,\n        'INVALID_MOD_ORDER'\n      );\n    }\n  }\n\n  async function interceptingMod({ modRequest, ...config }: ExportedConfigWithProps<T>) {\n    if (isDebug) {\n      // In debug mod, log the plugin stack in the order which they were invoked\n      console.log(debugTrace);\n    }\n    const results = await action({\n      ...config,\n      modRequest: { ...modRequest, nextMod: interceptedMod },\n    });\n\n    if (saveToInternal) {\n      saveToInternalObject(results, platform, mod, (results.modResults as unknown) as JSONObject);\n    }\n    return results;\n  }\n\n  // Ensure this base mod is registered as the provider.\n  interceptingMod.isProvider = isProvider;\n\n  if (isIntrospective) {\n    // Register the mode as idempotent so introspection doesn't remove it.\n    interceptingMod.isIntrospective = isIntrospective;\n  }\n\n  (config.mods[platform] as any)[mod] = interceptingMod;\n\n  return config;\n}\n\nfunction saveToInternalObject(\n  config: Pick<ExpoConfig, '_internal'>,\n  platformName: ModPlatform,\n  modName: string,\n  results: JSONObject\n) {\n  if (!config._internal) config._internal = {};\n  if (!config._internal.modResults) config._internal.modResults = {};\n  if (!config._internal.modResults[platformName]) config._internal.modResults[platformName] = {};\n  config._internal.modResults[platformName][modName] = results;\n}\n\nfunction getDebugPluginStackFromStackTrace(stacktrace?: string): string {\n  if (!stacktrace) {\n    return '';\n  }\n\n  const treeStackLines: string[] = [];\n  for (const line of stacktrace.split('\\n')) {\n    const [first, second] = line.trim().split(' ');\n    if (first === 'at') {\n      treeStackLines.push(second);\n    }\n  }\n\n  const plugins = treeStackLines\n    .map(first => {\n      // Match the first part of the stack trace against the plugin naming convention\n      // \"with\" followed by a capital letter.\n      return (\n        first?.match(/^(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        first?.match(/\\.(\\bwith[A-Z].*?\\b)/)?.[1]?.trim() ??\n        null\n      );\n    })\n    .filter(Boolean)\n    .filter(plugin => {\n      // redundant as all debug logs are captured in withBaseMod\n      return !['withMod', 'withBaseMod', 'withExtendedMod'].includes(plugin!);\n    });\n\n  const commonPlugins = ['withPlugins', 'withRunOnce', 'withStaticPlugin'];\n\n  return (\n    (plugins as string[])\n      .reverse()\n      .map((pluginName, index) => {\n        // Base mods indicate a logical section.\n        if (pluginName.includes('BaseMod')) {\n          pluginName = chalk.bold(pluginName);\n        }\n        // highlight dangerous mods\n        if (pluginName.toLowerCase().includes('dangerous')) {\n          pluginName = chalk.red(pluginName);\n        }\n\n        if (index === 0) {\n          return chalk.blue(pluginName);\n        } else if (commonPlugins.includes(pluginName)) {\n          // Common mod names often clutter up the logs, dim them out\n          return chalk.dim(pluginName);\n        }\n        return pluginName;\n      })\n      // Join the results:\n      // withAndroidExpoPlugins ➜ withPlugins ➜ withIcons ➜ withDangerousMod ➜ withMod\n      .join(' ➜ ')\n  );\n}\n\n/**\n * Plugin to extend a mod function in the plugins config.\n *\n * @param config exported config\n * @param platform platform to target (ios or android)\n * @param mod name of the platform function to extend\n * @param action method to run on the mod when the config is compiled\n */\nexport function withMod<T>(\n  config: ExportedConfig,\n  {\n    platform,\n    mod,\n    action,\n  }: {\n    platform: ModPlatform;\n    mod: string;\n    action: Mod<T>;\n  }\n): ExportedConfig {\n  return withBaseMod(config, {\n    platform,\n    mod,\n    isProvider: false,\n    async action({ modRequest: { nextMod, ...modRequest }, modResults, ...config }) {\n      const results = await action({ modRequest, modResults: modResults as T, ...config });\n      return nextMod!(results as any);\n    },\n  });\n}\n"]},"metadata":{},"sourceType":"script"}