{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.evalConfig=evalConfig;exports.resolveConfigExport=resolveConfigExport;function _fs(){var data=require(\"fs\");_fs=function _fs(){return data;};return data;}function _requireFromString(){var data=_interopRequireDefault(require(\"require-from-string\"));_requireFromString=function _requireFromString(){return data;};return data;}function _sucrase(){var data=require(\"sucrase\");_sucrase=function _sucrase(){return data;};return data;}function _Errors(){var data=require(\"./Errors\");_Errors=function _Errors(){return data;};return data;}function _Serialize(){var data=require(\"./Serialize\");_Serialize=function _Serialize(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */function evalConfig(configFile,request){var contents=(0,_fs().readFileSync)(configFile,'utf8');var result;try{var _ref=(0,_sucrase().transform)(contents,{filePath:configFile,transforms:['typescript','imports']}),code=_ref.code;result=(0,_requireFromString()[\"default\"])(code,configFile);}catch(error){var location=extractLocationFromSyntaxError(error);// Apply a code frame preview to the error if possible, sucrase doesn't do this by default.\nif(location){var _require=require('@babel/code-frame'),codeFrameColumns=_require.codeFrameColumns;var codeFrame=codeFrameColumns(contents,{start:error.loc},{highlightCode:true});error.codeFrame=codeFrame;error.message+=\"\\n\".concat(codeFrame);}else{var importantStack=extractImportantStackFromNodeError(error);if(importantStack){error.message+=\"\\n\".concat(importantStack);}}throw error;}return resolveConfigExport(result,configFile,request);}function extractLocationFromSyntaxError(error){// sucrase provides the `loc` object\nif(error.loc){return error.loc;}// `SyntaxError`s provide the `lineNumber` and `columnNumber` properties\nif('lineNumber'in error&&'columnNumber'in error){return{line:error.lineNumber,column:error.columnNumber};}return null;}// These kinda errors often come from syntax errors in files that were imported by the main file.\n// An example is a module that includes an import statement.\nfunction extractImportantStackFromNodeError(error){if(isSyntaxError(error)){var _error$stack;var traces=(_error$stack=error.stack)===null||_error$stack===void 0?void 0:_error$stack.split('\\n').filter(function(line){return!line.startsWith('    at ');});if(!traces)return null;// Remove redundant line\nif(traces[traces.length-1].startsWith('SyntaxError:')){traces.pop();}return traces.join('\\n');}return null;}function isSyntaxError(error){return error instanceof SyntaxError||error.constructor.name==='SyntaxError';}/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */function resolveConfigExport(result,configFile,request){var _result;if(result[\"default\"]!=null){result=result[\"default\"];}var exportedObjectType=typeof result;if(typeof result==='function'){result=result(request);}if(result instanceof Promise){throw new(_Errors().ConfigError)(\"Config file \".concat(configFile,\" cannot return a Promise.\"),'INVALID_CONFIG');}// If the expo object exists, ignore all other values.\nif((_result=result)!==null&&_result!==void 0&&_result.expo){result=(0,_Serialize().serializeSkippingMods)(result.expo);}else{result=(0,_Serialize().serializeSkippingMods)(result);}return{config:result,exportedObjectType:exportedObjectType};}","map":{"version":3,"sources":["../src/evalConfig.ts"],"names":["contents","code","filePath","transforms","result","location","extractLocationFromSyntaxError","codeFrameColumns","require","codeFrame","start","error","loc","highlightCode","importantStack","extractImportantStackFromNodeError","resolveConfigExport","line","column","columnNumber","isSyntaxError","traces","exportedObjectType","ConfigError","config"],"mappings":"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","sourcesContent":["import { readFileSync } from 'fs';\nimport requireString from 'require-from-string';\nimport { transform } from 'sucrase';\n\nimport { AppJSONConfig, ConfigContext, ExpoConfig } from './Config.types';\nimport { ConfigError } from './Errors';\nimport { serializeSkippingMods } from './Serialize';\n\ntype RawDynamicConfig = AppJSONConfig | Partial<ExpoConfig> | null;\n\nexport type DynamicConfigResults = { config: RawDynamicConfig; exportedObjectType: string };\n\n/**\n * Transpile and evaluate the dynamic config object.\n * This method is shared between the standard reading method in getConfig, and the headless script.\n *\n * @param options configFile path to the dynamic app.config.*, request to send to the dynamic config if it exports a function.\n * @returns the serialized and evaluated config along with the exported object type (object or function).\n */\nexport function evalConfig(\n  configFile: string,\n  request: ConfigContext | null\n): DynamicConfigResults {\n  const contents = readFileSync(configFile, 'utf8');\n  let result: any;\n  try {\n    const { code } = transform(contents, {\n      filePath: configFile,\n      transforms: ['typescript', 'imports'],\n    });\n\n    result = requireString(code, configFile);\n  } catch (error: any) {\n    const location = extractLocationFromSyntaxError(error);\n\n    // Apply a code frame preview to the error if possible, sucrase doesn't do this by default.\n    if (location) {\n      const { codeFrameColumns } = require('@babel/code-frame');\n      const codeFrame = codeFrameColumns(contents, { start: error.loc }, { highlightCode: true });\n      error.codeFrame = codeFrame;\n      error.message += `\\n${codeFrame}`;\n    } else {\n      const importantStack = extractImportantStackFromNodeError(error);\n\n      if (importantStack) {\n        error.message += `\\n${importantStack}`;\n      }\n    }\n    throw error;\n  }\n  return resolveConfigExport(result, configFile, request);\n}\n\nfunction extractLocationFromSyntaxError(\n  error: Error | any\n): { line: number; column?: number } | null {\n  // sucrase provides the `loc` object\n  if (error.loc) {\n    return error.loc;\n  }\n\n  // `SyntaxError`s provide the `lineNumber` and `columnNumber` properties\n  if ('lineNumber' in error && 'columnNumber' in error) {\n    return { line: error.lineNumber, column: error.columnNumber };\n  }\n\n  return null;\n}\n\n// These kinda errors often come from syntax errors in files that were imported by the main file.\n// An example is a module that includes an import statement.\nfunction extractImportantStackFromNodeError(error: any): string | null {\n  if (isSyntaxError(error)) {\n    const traces = error.stack?.split('\\n').filter(line => !line.startsWith('    at '));\n    if (!traces) return null;\n\n    // Remove redundant line\n    if (traces[traces.length - 1].startsWith('SyntaxError:')) {\n      traces.pop();\n    }\n    return traces.join('\\n');\n  }\n  return null;\n}\n\nfunction isSyntaxError(error: any): error is SyntaxError {\n  return error instanceof SyntaxError || error.constructor.name === 'SyntaxError';\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param result\n * @param configFile\n * @param request\n */\nexport function resolveConfigExport(\n  result: any,\n  configFile: string,\n  request: ConfigContext | null\n) {\n  if (result.default != null) {\n    result = result.default;\n  }\n  const exportedObjectType = typeof result;\n  if (typeof result === 'function') {\n    result = result(request);\n  }\n\n  if (result instanceof Promise) {\n    throw new ConfigError(`Config file ${configFile} cannot return a Promise.`, 'INVALID_CONFIG');\n  }\n\n  // If the expo object exists, ignore all other values.\n  if (result?.expo) {\n    result = serializeSkippingMods(result.expo);\n  } else {\n    result = serializeSkippingMods(result);\n  }\n\n  return { config: result, exportedObjectType };\n}\n"]},"metadata":{},"sourceType":"script"}