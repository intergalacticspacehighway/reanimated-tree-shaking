{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.assertInternalProjectRoot=assertInternalProjectRoot;exports.moduleNameIsDirectFileReference=moduleNameIsDirectFileReference;exports.normalizeStaticPlugin=normalizeStaticPlugin;exports.pluginFileName=void 0;exports.resolveConfigPluginExport=resolveConfigPluginExport;exports.resolveConfigPluginFunction=resolveConfigPluginFunction;exports.resolveConfigPluginFunctionWithInfo=resolveConfigPluginFunctionWithInfo;exports.resolvePluginForModule=resolvePluginForModule;function _assert(){var data=_interopRequireDefault(require(\"assert\"));_assert=function _assert(){return data;};return data;}function _findUp(){var data=_interopRequireDefault(require(\"find-up\"));_findUp=function _findUp(){return data;};return data;}function path(){var data=_interopRequireWildcard(require(\"path\"));path=function path(){return data;};return data;}function _resolveFrom(){var data=_interopRequireDefault(require(\"resolve-from\"));_resolveFrom=function _resolveFrom(){return data;};return data;}function _errors(){var data=require(\"./errors\");_errors=function _errors(){return data;};return data;}function _modules(){var data=require(\"./modules\");_modules=function _modules(){return data;};return data;}function _getRequireWildcardCache(nodeInterop){if(typeof WeakMap!==\"function\")return null;var cacheBabelInterop=new WeakMap();var cacheNodeInterop=new WeakMap();return(_getRequireWildcardCache=function _getRequireWildcardCache(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop;})(nodeInterop);}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{\"default\":obj};}var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(key!==\"default\"&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj[\"default\"]=obj;if(cache){cache.set(obj,newObj);}return newObj;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}// Default plugin entry file name.\nvar pluginFileName='app.plugin.js';exports.pluginFileName=pluginFileName;function findUpPackageJson(root){var packageJson=_findUp()[\"default\"].sync('package.json',{cwd:root});(0,_assert()[\"default\"])(packageJson,\"No package.json found for module \\\"\".concat(root,\"\\\"\"));return packageJson;}function resolvePluginForModule(projectRoot,modulePath){var resolved=_resolveFrom()[\"default\"].silent(projectRoot,modulePath);if(!resolved){throw new(_errors().PluginError)(\"Failed to resolve plugin for module \\\"\".concat(modulePath,\"\\\" relative to \\\"\").concat(projectRoot,\"\\\"\"),'PLUGIN_NOT_FOUND');}// If the modulePath is something like `@bacon/package/index.js` or `expo-foo/build/app`\n// then skip resolving the module `app.plugin.js`\nif(moduleNameIsDirectFileReference(modulePath)){return{isPluginFile:false,filePath:resolved};}return findUpPlugin(resolved);}// TODO: Test windows\nfunction pathIsFilePath(name){// Matches lines starting with: . / ~/\nreturn!!name.match(/^(\\.|~\\/|\\/)/g);}function moduleNameIsDirectFileReference(name){var _name$split;if(pathIsFilePath(name)){return true;}var slashCount=(_name$split=name.split(path().sep))===null||_name$split===void 0?void 0:_name$split.length;// Orgs (like @expo/config ) should have more than one slash to be a direct file.\nif(name.startsWith('@')){return slashCount>2;}// Regular packages should be considered direct reference if they have more than one slash.\nreturn slashCount>1;}function resolveExpoPluginFile(root){// Find the expo plugin root file\nvar pluginModuleFile=_resolveFrom()[\"default\"].silent(root,// use ./ so it isn't resolved as a node module\n\"./\".concat(pluginFileName));// If the default expo plugin file exists use it.\nif(pluginModuleFile&&(0,_modules().fileExists)(pluginModuleFile)){return pluginModuleFile;}return null;}function findUpPlugin(root){// Get the closest package.json to the node module\nvar packageJson=findUpPackageJson(root);// resolve the root folder for the node module\nvar moduleRoot=path().dirname(packageJson);// use whatever the initial resolved file was ex: `node_modules/my-package/index.js` or `./something.js`\nvar pluginFile=resolveExpoPluginFile(moduleRoot);return{filePath:pluginFile!==null&&pluginFile!==void 0?pluginFile:root,isPluginFile:!!pluginFile};}function normalizeStaticPlugin(plugin){if(Array.isArray(plugin)){(0,_assert()[\"default\"])(plugin.length>0&&plugin.length<3,\"Wrong number of arguments provided for static config plugin, expected either 1 or 2, got \".concat(plugin.length));return plugin;}return[plugin,undefined];}function assertInternalProjectRoot(projectRoot){(0,_assert()[\"default\"])(projectRoot,\"Unexpected: Config `_internal.projectRoot` isn't defined by expo-cli, this is a bug.\");}// Resolve the module function and assert type\nfunction resolveConfigPluginFunction(projectRoot,pluginReference){var _resolveConfigPluginF=resolveConfigPluginFunctionWithInfo(projectRoot,pluginReference),plugin=_resolveConfigPluginF.plugin;return plugin;}// Resolve the module function and assert type\nfunction resolveConfigPluginFunctionWithInfo(projectRoot,pluginReference){var _resolvePluginForModu=resolvePluginForModule(projectRoot,pluginReference),pluginFile=_resolvePluginForModu.filePath,isPluginFile=_resolvePluginForModu.isPluginFile;var result;try{result=requirePluginFile(pluginFile);}catch(error){if(error instanceof SyntaxError){var learnMoreLink=\"Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin\";// If the plugin reference is a node module, and that node module has a syntax error, then it probably doesn't have an official config plugin.\nif(!isPluginFile&&!moduleNameIsDirectFileReference(pluginReference)){var pluginError=new(_errors().PluginError)(\"Package \\\"\".concat(pluginReference,\"\\\" does not contain a valid config plugin.\\n\").concat(learnMoreLink,\"\\n\\n\").concat(error.message),'INVALID_PLUGIN_IMPORT');pluginError.stack=error.stack;throw pluginError;}}throw error;}var plugin=resolveConfigPluginExport({plugin:result,pluginFile:pluginFile,pluginReference:pluginReference,isPluginFile:isPluginFile});return{plugin:plugin,pluginFile:pluginFile,pluginReference:pluginReference,isPluginFile:isPluginFile};}/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param props.plugin plugin results\n * @param props.pluginFile plugin file path\n * @param props.pluginReference the string used to reference the plugin\n * @param props.isPluginFile is file path from the app.plugin.js module root\n */function resolveConfigPluginExport(_ref){var plugin=_ref.plugin,pluginFile=_ref.pluginFile,pluginReference=_ref.pluginReference,isPluginFile=_ref.isPluginFile;if(plugin[\"default\"]!=null){plugin=plugin[\"default\"];}if(typeof plugin!=='function'){var learnMoreLink=\"Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin\";// If the plugin reference is a node module, and that node module does not export a function then it probably doesn't have a config plugin.\nif(!isPluginFile&&!moduleNameIsDirectFileReference(pluginReference)){throw new(_errors().PluginError)(\"Package \\\"\".concat(pluginReference,\"\\\" does not contain a valid config plugin. Module must export a function from file: \").concat(pluginFile,\"\\n\").concat(learnMoreLink),'INVALID_PLUGIN_TYPE');}throw new(_errors().PluginError)(\"Plugin \\\"\".concat(pluginReference,\"\\\" must export a function from file: \").concat(pluginFile,\". \").concat(learnMoreLink),'INVALID_PLUGIN_TYPE');}return plugin;}function requirePluginFile(filePath){try{return require(filePath);}catch(error){// TODO: Improve error messages\nthrow error;}}","map":{"version":3,"sources":["../../src/utils/plugin-resolver.ts"],"names":["pluginFileName","packageJson","cwd","root","resolved","resolveFrom","PluginError","modulePath","moduleNameIsDirectFileReference","isPluginFile","filePath","findUpPlugin","name","pathIsFilePath","slashCount","path","pluginModuleFile","findUpPackageJson","moduleRoot","pluginFile","resolveExpoPluginFile","Array","plugin","resolveConfigPluginFunctionWithInfo","resolvePluginForModule","result","requirePluginFile","error","learnMoreLink","pluginError","pluginReference","resolveConfigPluginExport","require"],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport findUp from 'find-up';\nimport * as path from 'path';\nimport resolveFrom from 'resolve-from';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from './errors';\nimport { fileExists } from './modules';\n\n// Default plugin entry file name.\nexport const pluginFileName = 'app.plugin.js';\n\nfunction findUpPackageJson(root: string): string {\n  const packageJson = findUp.sync('package.json', { cwd: root });\n  assert(packageJson, `No package.json found for module \"${root}\"`);\n  return packageJson;\n}\n\nexport function resolvePluginForModule(projectRoot: string, modulePath: string) {\n  const resolved = resolveFrom.silent(projectRoot, modulePath);\n  if (!resolved) {\n    throw new PluginError(\n      `Failed to resolve plugin for module \"${modulePath}\" relative to \"${projectRoot}\"`,\n      'PLUGIN_NOT_FOUND'\n    );\n  }\n  // If the modulePath is something like `@bacon/package/index.js` or `expo-foo/build/app`\n  // then skip resolving the module `app.plugin.js`\n  if (moduleNameIsDirectFileReference(modulePath)) {\n    return { isPluginFile: false, filePath: resolved };\n  }\n  return findUpPlugin(resolved);\n}\n\n// TODO: Test windows\nfunction pathIsFilePath(name: string): boolean {\n  // Matches lines starting with: . / ~/\n  return !!name.match(/^(\\.|~\\/|\\/)/g);\n}\n\nexport function moduleNameIsDirectFileReference(name: string): boolean {\n  if (pathIsFilePath(name)) {\n    return true;\n  }\n\n  const slashCount = name.split(path.sep)?.length;\n  // Orgs (like @expo/config ) should have more than one slash to be a direct file.\n  if (name.startsWith('@')) {\n    return slashCount > 2;\n  }\n\n  // Regular packages should be considered direct reference if they have more than one slash.\n  return slashCount > 1;\n}\n\nfunction resolveExpoPluginFile(root: string): string | null {\n  // Find the expo plugin root file\n  const pluginModuleFile = resolveFrom.silent(\n    root,\n    // use ./ so it isn't resolved as a node module\n    `./${pluginFileName}`\n  );\n\n  // If the default expo plugin file exists use it.\n  if (pluginModuleFile && fileExists(pluginModuleFile)) {\n    return pluginModuleFile;\n  }\n  return null;\n}\n\nfunction findUpPlugin(root: string): { filePath: string; isPluginFile: boolean } {\n  // Get the closest package.json to the node module\n  const packageJson = findUpPackageJson(root);\n  // resolve the root folder for the node module\n  const moduleRoot = path.dirname(packageJson);\n  // use whatever the initial resolved file was ex: `node_modules/my-package/index.js` or `./something.js`\n  const pluginFile = resolveExpoPluginFile(moduleRoot);\n  return { filePath: pluginFile ?? root, isPluginFile: !!pluginFile };\n}\n\nexport function normalizeStaticPlugin(plugin: StaticPlugin | ConfigPlugin | string): StaticPlugin {\n  if (Array.isArray(plugin)) {\n    assert(\n      plugin.length > 0 && plugin.length < 3,\n      `Wrong number of arguments provided for static config plugin, expected either 1 or 2, got ${plugin.length}`\n    );\n    return plugin;\n  }\n  return [plugin, undefined];\n}\n\nexport function assertInternalProjectRoot(projectRoot?: string): asserts projectRoot {\n  assert(\n    projectRoot,\n    `Unexpected: Config \\`_internal.projectRoot\\` isn't defined by expo-cli, this is a bug.`\n  );\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunction(projectRoot: string, pluginReference: string) {\n  const { plugin } = resolveConfigPluginFunctionWithInfo(projectRoot, pluginReference);\n  return plugin;\n}\n\n// Resolve the module function and assert type\nexport function resolveConfigPluginFunctionWithInfo(projectRoot: string, pluginReference: string) {\n  const { filePath: pluginFile, isPluginFile } = resolvePluginForModule(\n    projectRoot,\n    pluginReference\n  );\n  let result: any;\n  try {\n    result = requirePluginFile(pluginFile);\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;\n      // If the plugin reference is a node module, and that node module has a syntax error, then it probably doesn't have an official config plugin.\n      if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n        const pluginError = new PluginError(\n          `Package \"${pluginReference}\" does not contain a valid config plugin.\\n${learnMoreLink}\\n\\n${error.message}`,\n          'INVALID_PLUGIN_IMPORT'\n        );\n        pluginError.stack = error.stack;\n        throw pluginError;\n      }\n    }\n    throw error;\n  }\n\n  const plugin = resolveConfigPluginExport({\n    plugin: result,\n    pluginFile,\n    pluginReference,\n    isPluginFile,\n  });\n  return { plugin, pluginFile, pluginReference, isPluginFile };\n}\n\n/**\n * - Resolve the exported contents of an Expo config (be it default or module.exports)\n * - Assert no promise exports\n * - Return config type\n * - Serialize config\n *\n * @param props.plugin plugin results\n * @param props.pluginFile plugin file path\n * @param props.pluginReference the string used to reference the plugin\n * @param props.isPluginFile is file path from the app.plugin.js module root\n */\nexport function resolveConfigPluginExport({\n  plugin,\n  pluginFile,\n  pluginReference,\n  isPluginFile,\n}: {\n  plugin: any;\n  pluginFile: string;\n  pluginReference: string;\n  isPluginFile: boolean;\n}): ConfigPlugin<unknown> {\n  if (plugin.default != null) {\n    plugin = plugin.default;\n  }\n  if (typeof plugin !== 'function') {\n    const learnMoreLink = `Learn more: https://docs.expo.dev/guides/config-plugins/#creating-a-plugin`;\n    // If the plugin reference is a node module, and that node module does not export a function then it probably doesn't have a config plugin.\n    if (!isPluginFile && !moduleNameIsDirectFileReference(pluginReference)) {\n      throw new PluginError(\n        `Package \"${pluginReference}\" does not contain a valid config plugin. Module must export a function from file: ${pluginFile}\\n${learnMoreLink}`,\n        'INVALID_PLUGIN_TYPE'\n      );\n    }\n    throw new PluginError(\n      `Plugin \"${pluginReference}\" must export a function from file: ${pluginFile}. ${learnMoreLink}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  return plugin;\n}\n\nfunction requirePluginFile(filePath: string): any {\n  try {\n    return require(filePath);\n  } catch (error) {\n    // TODO: Improve error messages\n    throw error;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}