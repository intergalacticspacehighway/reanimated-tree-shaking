{"ast":null,"code":"\"use strict\";function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.createBuildGradlePropsConfigPlugin=createBuildGradlePropsConfigPlugin;exports.updateAndroidBuildPropertiesFromConfig=updateAndroidBuildPropertiesFromConfig;exports.updateAndroidBuildProperty=updateAndroidBuildProperty;exports.withJsEngineGradleProps=void 0;function _androidPlugins(){var data=require(\"../plugins/android-plugins\");_androidPlugins=function _androidPlugins(){return data;};return data;}/**\n * Creates a `withGradleProperties` config-plugin based on given config to property mapping rules.\n *\n * The factory supports two modes from generic type inference\n * ```ts\n * // config-plugin without `props`, it will implicitly use the expo config as source config.\n * createBuildGradlePropsConfigPlugin<ExpoConfig>(): ConfigPlugin<void>;\n *\n * // config-plugin with a parameter `props: CustomType`, it will use the `props` as source config.\n * createBuildGradlePropsConfigPlugin<CustomType>(): ConfigPlugin<CustomType>;\n * ```\n *\n * @param configToPropertyRules config to property mapping rules\n * @param name the config plugin name\n */function createBuildGradlePropsConfigPlugin(configToPropertyRules,name){var withUnknown=function withUnknown(config,sourceConfig){return(0,_androidPlugins().withGradleProperties)(config,function(config){config.modResults=updateAndroidBuildPropertiesFromConfig(sourceConfig!==null&&sourceConfig!==void 0?sourceConfig:config,config.modResults,configToPropertyRules);return config;});};if(name){Object.defineProperty(withUnknown,'name',{value:name});}return withUnknown;}/**\n * A config-plugin to update `android/gradle.properties` from the `jsEngine` in expo config\n */var withJsEngineGradleProps=createBuildGradlePropsConfigPlugin([{propName:'expo.jsEngine',propValueGetter:function propValueGetter(config){var _ref,_config$android$jsEng,_config$android;return(_ref=(_config$android$jsEng=(_config$android=config.android)===null||_config$android===void 0?void 0:_config$android.jsEngine)!==null&&_config$android$jsEng!==void 0?_config$android$jsEng:config.jsEngine)!==null&&_ref!==void 0?_ref:'jsc';}}],'withJsEngineGradleProps');exports.withJsEngineGradleProps=withJsEngineGradleProps;function updateAndroidBuildPropertiesFromConfig(config,gradleProperties,configToPropertyRules){var _iterator=_createForOfIteratorHelper(configToPropertyRules),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var configToProperty=_step.value;var value=configToProperty.propValueGetter(config);updateAndroidBuildProperty(gradleProperties,configToProperty.propName,value);}}catch(err){_iterator.e(err);}finally{_iterator.f();}return gradleProperties;}function updateAndroidBuildProperty(gradleProperties,name,value,options){var oldPropIndex=gradleProperties.findIndex(function(prop){return prop.type==='property'&&prop.key===name;});if(value){// found the matched value, add or merge new property\nvar newProp={type:'property',key:name,value:value};if(oldPropIndex>=0){gradleProperties[oldPropIndex]=newProp;}else{gradleProperties.push(newProp);}}else if(options!==null&&options!==void 0&&options.removePropWhenValueIsNull&&oldPropIndex>=0){gradleProperties.splice(oldPropIndex,1);}return gradleProperties;}","map":{"version":3,"sources":["../../src/android/BuildProperties.ts"],"names":["withUnknown","config","updateAndroidBuildPropertiesFromConfig","sourceConfig","Object","value","name","withJsEngineGradleProps","createBuildGradlePropsConfigPlugin","propName","propValueGetter","configToProperty","updateAndroidBuildProperty","oldPropIndex","gradleProperties","prop","newProp","type","key","options"],"mappings":"ksDAGA,QAAA,CAAA,eAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAA,4BAAA,CAAA,CAAA,eAAA,CAAA,0BAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAAA,CAAA,kCAAA,CAAA,qBAAA,CAAA,IAAA,CAGL,CACA,GAAMA,CAAAA,WAAwF,CAAG,QAA3FA,CAAAA,WAA2F,CAAA,MAAA,CAAA,YAAA,QAI/F,CAAA,EAAA,eAAA,GAAA,oBAAA,EAAA,MAAA,CAA6BC,SAAAA,MAAM,CAAI,CACrCA,MAAM,CAANA,UAAAA,CAAoBC,sCAAsC,CACvDC,YADuD,GAAA,IACvDA,EAAAA,YADuD,GAAA,IAAA,EACvDA,CADuD,YACvDA,CADuD,MAAA,CAExDF,MAAM,CAFkD,UAAA,CAA1DA,qBAA0D,CAA1DA,CAKA,MAAA,CAAA,MAAA,CAVJ,CAIE,CAJ+F,EAAjG,CAYA,GAAA,IAAA,CAAU,CACRG,MAAM,CAANA,cAAAA,CAAAA,WAAAA,CAAAA,MAAAA,CAA2C,CACzCC,KAAK,CAAEC,IADkC,CAA3CF,EAGD,CACD,MAAA,CAAA,WAAA,CACD,CAED;AACA;AACA,GACO,GAAMG,CAAAA,uBAAuB,CAAGC,kCAAkC,CACvE,CACE,CACEC,QAAQ,CADV,eAAA,CAEEC,eAAe,CAAET,yBAAAA,MAAM,CAAA,CAAA,GAAA,CAAA,IAAA,CAAA,qBAAA,CAAA,eAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,qBAAA,CAAA,CAAA,eAAA,CAAIA,MAAM,CAAV,OAAA,IAAA,IAAA,EAAA,eAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAIA,eAAAA,CAAJ,QAAA,IAAA,IAAA,EAAA,qBAAA,GAAA,IAAA,EAAA,CAAA,qBAAA,CAAgCA,MAAM,CAAtC,QAAA,IAAA,IAAA,EAAA,IAAA,GAAA,IAAA,EAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAFzB,CADF,CADuE,CAAlE,yBAAkE,CAAlE,C,wDAUA,QAAA,CAAA,sCAAA,CAAA,MAAA,CAAA,gBAAA,CAAA,qBAAA,CAML,0CACA,qBADA,YACA,+CAAsD,IAAtD,CAAA,gBAAsD,aACpD,GAAMI,CAAAA,KAAK,CAAGM,gBAAgB,CAAhBA,eAAAA,CAAd,MAAcA,CAAd,CACAC,0BAA0B,CAAA,gBAAA,CAAmBD,gBAAgB,CAAnC,QAAA,CAA1BC,KAA0B,CAA1BA,CACD,CAJD,qDAMA,MAAA,CAAA,gBAAA,CACD,CAEM,QAAA,CAAA,0BAAA,CAAA,gBAAA,CAAA,IAAA,CAAA,KAAA,CAAA,OAAA,CAKL,CACA,GAAMC,CAAAA,YAAY,CAAGC,gBAAgB,CAAhBA,SAAAA,CACnBC,SAAAA,IAAI,QAAIA,CAAAA,IAAI,CAAJA,IAAAA,GAAAA,UAAAA,EAA4BA,IAAI,CAAJA,GAAAA,GADtC,IACM,EADeD,CAArB,CAIA,GAAA,KAAA,CAAW,CACT;AACA,GAAME,CAAAA,OAAuB,CAAG,CAC9BC,IAAI,CAD0B,UAAA,CAE9BC,GAAG,CAF2B,IAAA,CAG9Bb,KAAAA,CAAAA,KAH8B,CAAhC,CAMA,GAAIQ,YAAY,EAAhB,CAAA,CAAuB,CACrBC,gBAAgB,CAAhBA,YAAgB,CAAhBA,CAAAA,OAAAA,CADF,CAAA,IAEO,CACLA,gBAAgB,CAAhBA,IAAAA,CAAAA,OAAAA,EACD,CAZH,CAAA,IAaO,IAAIK,OAAO,GAAPA,IAAAA,EAAAA,OAAO,GAAA,IAAPA,EAAAA,EAAAA,OAAO,CAAPA,yBAAAA,EAAsCN,YAAY,EAAtD,CAAA,CAA6D,CAClEC,gBAAgB,CAAhBA,MAAAA,CAAAA,YAAAA,CAAAA,CAAAA,EACD,CAED,MAAA,CAAA,gBAAA,CACD","sourcesContent":["import type { ExpoConfig } from '@expo/config-types';\n\nimport type { ConfigPlugin } from '../Plugin.types';\nimport { withGradleProperties } from '../plugins/android-plugins';\nimport { BuildPropertiesConfig, ConfigToPropertyRuleType } from '../utils/BuildProperties.types';\nimport type { PropertiesItem } from './Properties';\n\n/**\n * Creates a `withGradleProperties` config-plugin based on given config to property mapping rules.\n *\n * The factory supports two modes from generic type inference\n * ```ts\n * // config-plugin without `props`, it will implicitly use the expo config as source config.\n * createBuildGradlePropsConfigPlugin<ExpoConfig>(): ConfigPlugin<void>;\n *\n * // config-plugin with a parameter `props: CustomType`, it will use the `props` as source config.\n * createBuildGradlePropsConfigPlugin<CustomType>(): ConfigPlugin<CustomType>;\n * ```\n *\n * @param configToPropertyRules config to property mapping rules\n * @param name the config plugin name\n */\nexport function createBuildGradlePropsConfigPlugin<SourceConfigType extends BuildPropertiesConfig>(\n  configToPropertyRules: ConfigToPropertyRuleType<SourceConfigType>[],\n  name?: string\n) {\n  const withUnknown: ConfigPlugin<SourceConfigType extends ExpoConfig ? void : SourceConfigType> = (\n    config,\n    sourceConfig\n  ) =>\n    withGradleProperties(config, config => {\n      config.modResults = updateAndroidBuildPropertiesFromConfig(\n        (sourceConfig ?? config) as SourceConfigType,\n        config.modResults,\n        configToPropertyRules\n      );\n      return config;\n    });\n  if (name) {\n    Object.defineProperty(withUnknown, 'name', {\n      value: name,\n    });\n  }\n  return withUnknown;\n}\n\n/**\n * A config-plugin to update `android/gradle.properties` from the `jsEngine` in expo config\n */\nexport const withJsEngineGradleProps = createBuildGradlePropsConfigPlugin<ExpoConfig>(\n  [\n    {\n      propName: 'expo.jsEngine',\n      propValueGetter: config => config.android?.jsEngine ?? config.jsEngine ?? 'jsc',\n    },\n  ],\n  'withJsEngineGradleProps'\n);\n\nexport function updateAndroidBuildPropertiesFromConfig<\n  SourceConfigType extends BuildPropertiesConfig\n>(\n  config: SourceConfigType,\n  gradleProperties: PropertiesItem[],\n  configToPropertyRules: ConfigToPropertyRuleType<SourceConfigType>[]\n) {\n  for (const configToProperty of configToPropertyRules) {\n    const value = configToProperty.propValueGetter(config);\n    updateAndroidBuildProperty(gradleProperties, configToProperty.propName, value);\n  }\n\n  return gradleProperties;\n}\n\nexport function updateAndroidBuildProperty(\n  gradleProperties: PropertiesItem[],\n  name: string,\n  value: string | null | undefined,\n  options?: { removePropWhenValueIsNull?: boolean }\n) {\n  const oldPropIndex = gradleProperties.findIndex(\n    prop => prop.type === 'property' && prop.key === name\n  );\n\n  if (value) {\n    // found the matched value, add or merge new property\n    const newProp: PropertiesItem = {\n      type: 'property',\n      key: name,\n      value,\n    };\n\n    if (oldPropIndex >= 0) {\n      gradleProperties[oldPropIndex] = newProp;\n    } else {\n      gradleProperties.push(newProp);\n    }\n  } else if (options?.removePropWhenValueIsNull && oldPropIndex >= 0) {\n    gradleProperties.splice(oldPropIndex, 1);\n  }\n\n  return gradleProperties;\n}\n"]},"metadata":{},"sourceType":"script"}