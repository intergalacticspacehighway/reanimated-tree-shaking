{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */ /*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */var util=require('./util');var binarySearch=require('./binary-search');var ArraySet=require('./array-set').ArraySet;var base64VLQ=require('./base64-vlq');var quickSort=require('./quick-sort').quickSort;function SourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/,''));}return sourceMap.sections!=null?new IndexedSourceMapConsumer(sourceMap):new BasicSourceMapConsumer(sourceMap);}SourceMapConsumer.fromSourceMap=function(aSourceMap){return BasicSourceMapConsumer.fromSourceMap(aSourceMap);};/**\n * The version of the source mapping spec that we are consuming.\n */SourceMapConsumer.prototype._version=3;// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\nSourceMapConsumer.prototype.__generatedMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_generatedMappings',{get:function get(){if(!this.__generatedMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__generatedMappings;}});SourceMapConsumer.prototype.__originalMappings=null;Object.defineProperty(SourceMapConsumer.prototype,'_originalMappings',{get:function get(){if(!this.__originalMappings){this._parseMappings(this._mappings,this.sourceRoot);}return this.__originalMappings;}});SourceMapConsumer.prototype._charIsMappingSeparator=function SourceMapConsumer_charIsMappingSeparator(aStr,index){var c=aStr.charAt(index);return c===\";\"||c===\",\";};/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */SourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){throw new Error(\"Subclasses must implement _parseMappings\");};SourceMapConsumer.GENERATED_ORDER=1;SourceMapConsumer.ORIGINAL_ORDER=2;SourceMapConsumer.GREATEST_LOWER_BOUND=1;SourceMapConsumer.LEAST_UPPER_BOUND=2;/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */SourceMapConsumer.prototype.eachMapping=function SourceMapConsumer_eachMapping(aCallback,aContext,aOrder){var context=aContext||null;var order=aOrder||SourceMapConsumer.GENERATED_ORDER;var mappings;switch(order){case SourceMapConsumer.GENERATED_ORDER:mappings=this._generatedMappings;break;case SourceMapConsumer.ORIGINAL_ORDER:mappings=this._originalMappings;break;default:throw new Error(\"Unknown order of iteration.\");}var sourceRoot=this.sourceRoot;mappings.map(function(mapping){var source=mapping.source===null?null:this._sources.at(mapping.source);if(source!=null&&sourceRoot!=null){source=util.join(sourceRoot,source);}return{source:source,generatedLine:mapping.generatedLine,generatedColumn:mapping.generatedColumn,originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:mapping.name===null?null:this._names.at(mapping.name)};},this).forEach(aCallback,context);};/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */SourceMapConsumer.prototype.allGeneratedPositionsFor=function SourceMapConsumer_allGeneratedPositionsFor(aArgs){var line=util.getArg(aArgs,'line');// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n// returns the index of the closest mapping less than the needle. By\n// setting needle.originalColumn to 0, we thus find the last mapping for\n// the given line, provided such a mapping exists.\nvar needle={source:util.getArg(aArgs,'source'),originalLine:line,originalColumn:util.getArg(aArgs,'column',0)};if(this.sourceRoot!=null){needle.source=util.relative(this.sourceRoot,needle.source);}if(!this._sources.has(needle.source)){return[];}needle.source=this._sources.indexOf(needle.source);var mappings=[];var index=this._findMapping(needle,this._originalMappings,\"originalLine\",\"originalColumn\",util.compareByOriginalPositions,binarySearch.LEAST_UPPER_BOUND);if(index>=0){var mapping=this._originalMappings[index];if(aArgs.column===undefined){var originalLine=mapping.originalLine;// Iterate until either we run out of mappings, or we run into\n// a mapping for a different line than the one we found. Since\n// mappings are sorted, this is guaranteed to find all mappings for\n// the line we found.\nwhile(mapping&&mapping.originalLine===originalLine){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}else{var originalColumn=mapping.originalColumn;// Iterate until either we run out of mappings, or we run into\n// a mapping for a different line than the one we were searching for.\n// Since mappings are sorted, this is guaranteed to find all mappings for\n// the line we are searching for.\nwhile(mapping&&mapping.originalLine===line&&mapping.originalColumn==originalColumn){mappings.push({line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)});mapping=this._originalMappings[++index];}}}return mappings;};exports.SourceMapConsumer=SourceMapConsumer;/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */function BasicSourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/,''));}var version=util.getArg(sourceMap,'version');var sources=util.getArg(sourceMap,'sources');// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n// requires the array) to play nice here.\nvar names=util.getArg(sourceMap,'names',[]);var sourceRoot=util.getArg(sourceMap,'sourceRoot',null);var sourcesContent=util.getArg(sourceMap,'sourcesContent',null);var mappings=util.getArg(sourceMap,'mappings');var file=util.getArg(sourceMap,'file',null);// Once again, Sass deviates from the spec and supplies the version as a\n// string rather than a number, so we use loose equality checking here.\nif(version!=this._version){throw new Error('Unsupported version: '+version);}sources=sources.map(String)// Some source maps produce relative source paths like \"./foo.js\" instead of\n// \"foo.js\".  Normalize these first so that future comparisons will succeed.\n// See bugzil.la/1090768.\n.map(util.normalize)// Always ensure that absolute sources are internally stored relative to\n// the source root, if the source root is absolute. Not doing this would\n// be particularly problematic when the source root is a prefix of the\n// source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n.map(function(source){return sourceRoot&&util.isAbsolute(sourceRoot)&&util.isAbsolute(source)?util.relative(sourceRoot,source):source;});// Pass `true` below to allow duplicate names and sources. While source maps\n// are intended to be compressed and deduplicated, the TypeScript compiler\n// sometimes generates source maps with duplicates in them. See Github issue\n// #72 and bugzil.la/889492.\nthis._names=ArraySet.fromArray(names.map(String),true);this._sources=ArraySet.fromArray(sources,true);this.sourceRoot=sourceRoot;this.sourcesContent=sourcesContent;this._mappings=mappings;this.file=file;}BasicSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);BasicSourceMapConsumer.prototype.consumer=SourceMapConsumer;/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */BasicSourceMapConsumer.fromSourceMap=function SourceMapConsumer_fromSourceMap(aSourceMap){var smc=Object.create(BasicSourceMapConsumer.prototype);var names=smc._names=ArraySet.fromArray(aSourceMap._names.toArray(),true);var sources=smc._sources=ArraySet.fromArray(aSourceMap._sources.toArray(),true);smc.sourceRoot=aSourceMap._sourceRoot;smc.sourcesContent=aSourceMap._generateSourcesContent(smc._sources.toArray(),smc.sourceRoot);smc.file=aSourceMap._file;// Because we are modifying the entries (by converting string sources and\n// names to indices into the sources and names ArraySets), we have to make\n// a copy of the entry or else bad things happen. Shared mutable state\n// strikes again! See github issue #191.\nvar generatedMappings=aSourceMap._mappings.toArray().slice();var destGeneratedMappings=smc.__generatedMappings=[];var destOriginalMappings=smc.__originalMappings=[];for(var i=0,length=generatedMappings.length;i<length;i++){var srcMapping=generatedMappings[i];var destMapping=new Mapping();destMapping.generatedLine=srcMapping.generatedLine;destMapping.generatedColumn=srcMapping.generatedColumn;if(srcMapping.source){destMapping.source=sources.indexOf(srcMapping.source);destMapping.originalLine=srcMapping.originalLine;destMapping.originalColumn=srcMapping.originalColumn;if(srcMapping.name){destMapping.name=names.indexOf(srcMapping.name);}destOriginalMappings.push(destMapping);}destGeneratedMappings.push(destMapping);}quickSort(smc.__originalMappings,util.compareByOriginalPositions);return smc;};/**\n * The version of the source mapping spec that we are consuming.\n */BasicSourceMapConsumer.prototype._version=3;/**\n * The list of original sources.\n */Object.defineProperty(BasicSourceMapConsumer.prototype,'sources',{get:function get(){return this._sources.toArray().map(function(s){return this.sourceRoot!=null?util.join(this.sourceRoot,s):s;},this);}});/**\n * Provide the JIT with a nice shape / hidden class.\n */function Mapping(){this.generatedLine=0;this.generatedColumn=0;this.source=null;this.originalLine=null;this.originalColumn=null;this.name=null;}/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */BasicSourceMapConsumer.prototype._parseMappings=function SourceMapConsumer_parseMappings(aStr,aSourceRoot){var generatedLine=1;var previousGeneratedColumn=0;var previousOriginalLine=0;var previousOriginalColumn=0;var previousSource=0;var previousName=0;var length=aStr.length;var index=0;var cachedSegments={};var temp={};var originalMappings=[];var generatedMappings=[];var mapping,str,segment,end,value;while(index<length){if(aStr.charAt(index)===';'){generatedLine++;index++;previousGeneratedColumn=0;}else if(aStr.charAt(index)===','){index++;}else{mapping=new Mapping();mapping.generatedLine=generatedLine;// Because each offset is encoded relative to the previous one,\n// many segments often have the same encoding. We can exploit this\n// fact by caching the parsed variable length fields of each segment,\n// allowing us to avoid a second parse if we encounter the same\n// segment again.\nfor(end=index;end<length;end++){if(this._charIsMappingSeparator(aStr,end)){break;}}str=aStr.slice(index,end);segment=cachedSegments[str];if(segment){index+=str.length;}else{segment=[];while(index<end){base64VLQ.decode(aStr,index,temp);value=temp.value;index=temp.rest;segment.push(value);}if(segment.length===2){throw new Error('Found a source, but no line and column');}if(segment.length===3){throw new Error('Found a source and line, but no column');}cachedSegments[str]=segment;}// Generated column.\nmapping.generatedColumn=previousGeneratedColumn+segment[0];previousGeneratedColumn=mapping.generatedColumn;if(segment.length>1){// Original source.\nmapping.source=previousSource+segment[1];previousSource+=segment[1];// Original line.\nmapping.originalLine=previousOriginalLine+segment[2];previousOriginalLine=mapping.originalLine;// Lines are stored 0-based\nmapping.originalLine+=1;// Original column.\nmapping.originalColumn=previousOriginalColumn+segment[3];previousOriginalColumn=mapping.originalColumn;if(segment.length>4){// Original name.\nmapping.name=previousName+segment[4];previousName+=segment[4];}}generatedMappings.push(mapping);if(typeof mapping.originalLine==='number'){originalMappings.push(mapping);}}}quickSort(generatedMappings,util.compareByGeneratedPositionsDeflated);this.__generatedMappings=generatedMappings;quickSort(originalMappings,util.compareByOriginalPositions);this.__originalMappings=originalMappings;};/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */BasicSourceMapConsumer.prototype._findMapping=function SourceMapConsumer_findMapping(aNeedle,aMappings,aLineName,aColumnName,aComparator,aBias){// To return the position we are searching for, we must first find the\n// mapping for the given position and then return the opposite position it\n// points to. Because the mappings are sorted, we can use binary search to\n// find the best mapping.\nif(aNeedle[aLineName]<=0){throw new TypeError('Line must be greater than or equal to 1, got '+aNeedle[aLineName]);}if(aNeedle[aColumnName]<0){throw new TypeError('Column must be greater than or equal to 0, got '+aNeedle[aColumnName]);}return binarySearch.search(aNeedle,aMappings,aComparator,aBias);};/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */BasicSourceMapConsumer.prototype.computeColumnSpans=function SourceMapConsumer_computeColumnSpans(){for(var index=0;index<this._generatedMappings.length;++index){var mapping=this._generatedMappings[index];// Mappings do not contain a field for the last generated columnt. We\n// can come up with an optimistic estimate, however, by assuming that\n// mappings are contiguous (i.e. given two consecutive mappings, the\n// first mapping ends where the second one starts).\nif(index+1<this._generatedMappings.length){var nextMapping=this._generatedMappings[index+1];if(mapping.generatedLine===nextMapping.generatedLine){mapping.lastGeneratedColumn=nextMapping.generatedColumn-1;continue;}}// The last mapping for each line spans the entire line.\nmapping.lastGeneratedColumn=Infinity;}};/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */BasicSourceMapConsumer.prototype.originalPositionFor=function SourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._generatedMappings,\"generatedLine\",\"generatedColumn\",util.compareByGeneratedPositionsDeflated,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._generatedMappings[index];if(mapping.generatedLine===needle.generatedLine){var source=util.getArg(mapping,'source',null);if(source!==null){source=this._sources.at(source);if(this.sourceRoot!=null){source=util.join(this.sourceRoot,source);}}var name=util.getArg(mapping,'name',null);if(name!==null){name=this._names.at(name);}return{source:source,line:util.getArg(mapping,'originalLine',null),column:util.getArg(mapping,'originalColumn',null),name:name};}}return{source:null,line:null,column:null,name:null};};/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */BasicSourceMapConsumer.prototype.hasContentsOfAllSources=function BasicSourceMapConsumer_hasContentsOfAllSources(){if(!this.sourcesContent){return false;}return this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(sc){return sc==null;});};/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */BasicSourceMapConsumer.prototype.sourceContentFor=function SourceMapConsumer_sourceContentFor(aSource,nullOnMissing){if(!this.sourcesContent){return null;}if(this.sourceRoot!=null){aSource=util.relative(this.sourceRoot,aSource);}if(this._sources.has(aSource)){return this.sourcesContent[this._sources.indexOf(aSource)];}var url;if(this.sourceRoot!=null&&(url=util.urlParse(this.sourceRoot))){// XXX: file:// URIs and absolute paths lead to unexpected behavior for\n// many users. We can help them out when they expect file:// URIs to\n// behave like it would if they were running a local HTTP server. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\nvar fileUriAbsPath=aSource.replace(/^file:\\/\\//,\"\");if(url.scheme==\"file\"&&this._sources.has(fileUriAbsPath)){return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];}if((!url.path||url.path==\"/\")&&this._sources.has(\"/\"+aSource)){return this.sourcesContent[this._sources.indexOf(\"/\"+aSource)];}}// This function is used recursively from\n// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n// don't want to throw if we can't find the source - we just want to\n// return null, so we provide a flag to exit gracefully.\nif(nullOnMissing){return null;}else{throw new Error('\"'+aSource+'\" is not in the SourceMap.');}};/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */BasicSourceMapConsumer.prototype.generatedPositionFor=function SourceMapConsumer_generatedPositionFor(aArgs){var source=util.getArg(aArgs,'source');if(this.sourceRoot!=null){source=util.relative(this.sourceRoot,source);}if(!this._sources.has(source)){return{line:null,column:null,lastColumn:null};}source=this._sources.indexOf(source);var needle={source:source,originalLine:util.getArg(aArgs,'line'),originalColumn:util.getArg(aArgs,'column')};var index=this._findMapping(needle,this._originalMappings,\"originalLine\",\"originalColumn\",util.compareByOriginalPositions,util.getArg(aArgs,'bias',SourceMapConsumer.GREATEST_LOWER_BOUND));if(index>=0){var mapping=this._originalMappings[index];if(mapping.source===needle.source){return{line:util.getArg(mapping,'generatedLine',null),column:util.getArg(mapping,'generatedColumn',null),lastColumn:util.getArg(mapping,'lastGeneratedColumn',null)};}}return{line:null,column:null,lastColumn:null};};exports.BasicSourceMapConsumer=BasicSourceMapConsumer;/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */function IndexedSourceMapConsumer(aSourceMap){var sourceMap=aSourceMap;if(typeof aSourceMap==='string'){sourceMap=JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/,''));}var version=util.getArg(sourceMap,'version');var sections=util.getArg(sourceMap,'sections');if(version!=this._version){throw new Error('Unsupported version: '+version);}this._sources=new ArraySet();this._names=new ArraySet();var lastOffset={line:-1,column:0};this._sections=sections.map(function(s){if(s.url){// The url field will require support for asynchronicity.\n// See https://github.com/mozilla/source-map/issues/16\nthrow new Error('Support for url field in sections not implemented.');}var offset=util.getArg(s,'offset');var offsetLine=util.getArg(offset,'line');var offsetColumn=util.getArg(offset,'column');if(offsetLine<lastOffset.line||offsetLine===lastOffset.line&&offsetColumn<lastOffset.column){throw new Error('Section offsets must be ordered and non-overlapping.');}lastOffset=offset;return{generatedOffset:{// The offset fields are 0-based, but we use 1-based indices when\n// encoding/decoding from VLQ.\ngeneratedLine:offsetLine+1,generatedColumn:offsetColumn+1},consumer:new SourceMapConsumer(util.getArg(s,'map'))};});}IndexedSourceMapConsumer.prototype=Object.create(SourceMapConsumer.prototype);IndexedSourceMapConsumer.prototype.constructor=SourceMapConsumer;/**\n * The version of the source mapping spec that we are consuming.\n */IndexedSourceMapConsumer.prototype._version=3;/**\n * The list of original sources.\n */Object.defineProperty(IndexedSourceMapConsumer.prototype,'sources',{get:function get(){var sources=[];for(var i=0;i<this._sections.length;i++){for(var j=0;j<this._sections[i].consumer.sources.length;j++){sources.push(this._sections[i].consumer.sources[j]);}}return sources;}});/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */IndexedSourceMapConsumer.prototype.originalPositionFor=function IndexedSourceMapConsumer_originalPositionFor(aArgs){var needle={generatedLine:util.getArg(aArgs,'line'),generatedColumn:util.getArg(aArgs,'column')};// Find the section containing the generated position we're trying to map\n// to an original position.\nvar sectionIndex=binarySearch.search(needle,this._sections,function(needle,section){var cmp=needle.generatedLine-section.generatedOffset.generatedLine;if(cmp){return cmp;}return needle.generatedColumn-section.generatedOffset.generatedColumn;});var section=this._sections[sectionIndex];if(!section){return{source:null,line:null,column:null,name:null};}return section.consumer.originalPositionFor({line:needle.generatedLine-(section.generatedOffset.generatedLine-1),column:needle.generatedColumn-(section.generatedOffset.generatedLine===needle.generatedLine?section.generatedOffset.generatedColumn-1:0),bias:aArgs.bias});};/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */IndexedSourceMapConsumer.prototype.hasContentsOfAllSources=function IndexedSourceMapConsumer_hasContentsOfAllSources(){return this._sections.every(function(s){return s.consumer.hasContentsOfAllSources();});};/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */IndexedSourceMapConsumer.prototype.sourceContentFor=function IndexedSourceMapConsumer_sourceContentFor(aSource,nullOnMissing){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var content=section.consumer.sourceContentFor(aSource,true);if(content){return content;}}if(nullOnMissing){return null;}else{throw new Error('\"'+aSource+'\" is not in the SourceMap.');}};/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */IndexedSourceMapConsumer.prototype.generatedPositionFor=function IndexedSourceMapConsumer_generatedPositionFor(aArgs){for(var i=0;i<this._sections.length;i++){var section=this._sections[i];// Only consider this section if the requested source is in the list of\n// sources of the consumer.\nif(section.consumer.sources.indexOf(util.getArg(aArgs,'source'))===-1){continue;}var generatedPosition=section.consumer.generatedPositionFor(aArgs);if(generatedPosition){var ret={line:generatedPosition.line+(section.generatedOffset.generatedLine-1),column:generatedPosition.column+(section.generatedOffset.generatedLine===generatedPosition.line?section.generatedOffset.generatedColumn-1:0)};return ret;}}return{line:null,column:null};};/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */IndexedSourceMapConsumer.prototype._parseMappings=function IndexedSourceMapConsumer_parseMappings(aStr,aSourceRoot){this.__generatedMappings=[];this.__originalMappings=[];for(var i=0;i<this._sections.length;i++){var section=this._sections[i];var sectionMappings=section.consumer._generatedMappings;for(var j=0;j<sectionMappings.length;j++){var mapping=sectionMappings[j];var source=section.consumer._sources.at(mapping.source);if(section.consumer.sourceRoot!==null){source=util.join(section.consumer.sourceRoot,source);}this._sources.add(source);source=this._sources.indexOf(source);var name=section.consumer._names.at(mapping.name);this._names.add(name);name=this._names.indexOf(name);// The mappings coming from the consumer for the section have\n// generated positions relative to the start of the section, so we\n// need to offset them to be relative to the start of the concatenated\n// generated file.\nvar adjustedMapping={source:source,generatedLine:mapping.generatedLine+(section.generatedOffset.generatedLine-1),generatedColumn:mapping.generatedColumn+(section.generatedOffset.generatedLine===mapping.generatedLine?section.generatedOffset.generatedColumn-1:0),originalLine:mapping.originalLine,originalColumn:mapping.originalColumn,name:name};this.__generatedMappings.push(adjustedMapping);if(typeof adjustedMapping.originalLine==='number'){this.__originalMappings.push(adjustedMapping);}}}quickSort(this.__generatedMappings,util.compareByGeneratedPositionsDeflated);quickSort(this.__originalMappings,util.compareByOriginalPositions);};exports.IndexedSourceMapConsumer=IndexedSourceMapConsumer;","map":{"version":3,"names":["util","require","binarySearch","ArraySet","base64VLQ","quickSort","SourceMapConsumer","aSourceMap","sourceMap","JSON","parse","replace","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","fromSourceMap","prototype","_version","__generatedMappings","Object","defineProperty","get","_parseMappings","_mappings","sourceRoot","__originalMappings","_charIsMappingSeparator","SourceMapConsumer_charIsMappingSeparator","aStr","index","c","charAt","SourceMapConsumer_parseMappings","aSourceRoot","Error","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","eachMapping","SourceMapConsumer_eachMapping","aCallback","aContext","aOrder","context","order","mappings","_generatedMappings","_originalMappings","map","mapping","source","_sources","at","join","generatedLine","generatedColumn","originalLine","originalColumn","name","_names","forEach","allGeneratedPositionsFor","SourceMapConsumer_allGeneratedPositionsFor","aArgs","line","getArg","needle","relative","has","indexOf","_findMapping","compareByOriginalPositions","column","undefined","push","lastColumn","exports","version","sources","names","sourcesContent","file","String","normalize","isAbsolute","fromArray","create","consumer","SourceMapConsumer_fromSourceMap","smc","toArray","_sourceRoot","_generateSourcesContent","_file","generatedMappings","slice","destGeneratedMappings","destOriginalMappings","i","length","srcMapping","destMapping","Mapping","s","previousGeneratedColumn","previousOriginalLine","previousOriginalColumn","previousSource","previousName","cachedSegments","temp","originalMappings","str","segment","end","value","decode","rest","compareByGeneratedPositionsDeflated","SourceMapConsumer_findMapping","aNeedle","aMappings","aLineName","aColumnName","aComparator","aBias","TypeError","search","computeColumnSpans","SourceMapConsumer_computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","originalPositionFor","SourceMapConsumer_originalPositionFor","hasContentsOfAllSources","BasicSourceMapConsumer_hasContentsOfAllSources","size","some","sc","sourceContentFor","SourceMapConsumer_sourceContentFor","aSource","nullOnMissing","url","urlParse","fileUriAbsPath","scheme","path","generatedPositionFor","SourceMapConsumer_generatedPositionFor","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","constructor","j","IndexedSourceMapConsumer_originalPositionFor","sectionIndex","section","cmp","bias","IndexedSourceMapConsumer_hasContentsOfAllSources","every","IndexedSourceMapConsumer_sourceContentFor","content","IndexedSourceMapConsumer_generatedPositionFor","generatedPosition","ret","IndexedSourceMapConsumer_parseMappings","sectionMappings","add","adjustedMapping"],"sources":["/Users/fernandorojo/Developer/messing/rea-tree/node_modules/@expo/webpack-config/node_modules/source-map/lib/source-map-consumer.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}