{"ast":null,"code":"\"use strict\";var _regeneratorRuntime=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/regenerator\");var _asyncToGenerator=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/asyncToGenerator\");var _defineProperty=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/defineProperty\");var _slicedToArray=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray\");var _objectWithoutProperties=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/objectWithoutProperties\");var _excluded=[\"mods\"];function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}Object.defineProperty(exports,\"__esModule\",{value:true});var _exportNames={getConfig:true,getPackageJson:true,readConfigJson:true,getConfigFilePaths:true,findConfigFile:true,configFilename:true,readExpRcAsync:true,resetCustomConfigPaths:true,setCustomConfigPath:true,modifyConfigAsync:true,writeConfigJsonAsync:true,getWebOutputPath:true,getNameFromConfig:true,getDefaultTarget:true,getProjectConfigDescription:true,getProjectConfigDescriptionWithPaths:true,isLegacyImportsEnabled:true};exports.configFilename=configFilename;exports.findConfigFile=findConfigFile;exports.getConfig=getConfig;exports.getConfigFilePaths=getConfigFilePaths;exports.getDefaultTarget=getDefaultTarget;exports.getNameFromConfig=getNameFromConfig;exports.getPackageJson=getPackageJson;exports.getProjectConfigDescription=getProjectConfigDescription;exports.getProjectConfigDescriptionWithPaths=getProjectConfigDescriptionWithPaths;exports.getWebOutputPath=getWebOutputPath;Object.defineProperty(exports,\"isLegacyImportsEnabled\",{enumerable:true,get:function get(){return _isLegacyImportsEnabled().isLegacyImportsEnabled;}});exports.modifyConfigAsync=modifyConfigAsync;exports.readConfigJson=readConfigJson;exports.readExpRcAsync=readExpRcAsync;exports.resetCustomConfigPaths=resetCustomConfigPaths;exports.setCustomConfigPath=setCustomConfigPath;exports.writeConfigJsonAsync=writeConfigJsonAsync;function _jsonFile(){var data=_interopRequireDefault(require(\"@expo/json-file\"));_jsonFile=function _jsonFile(){return data;};return data;}function _fs(){var data=_interopRequireDefault(require(\"fs\"));_fs=function _fs(){return data;};return data;}function _glob(){var data=require(\"glob\");_glob=function _glob(){return data;};return data;}function _path(){var data=_interopRequireDefault(require(\"path\"));_path=function _path(){return data;};return data;}function _resolveFrom(){var data=_interopRequireDefault(require(\"resolve-from\"));_resolveFrom=function _resolveFrom(){return data;};return data;}function _semver(){var data=_interopRequireDefault(require(\"semver\"));_semver=function _semver(){return data;};return data;}function _slugify(){var data=_interopRequireDefault(require(\"slugify\"));_slugify=function _slugify(){return data;};return data;}function _Errors(){var data=require(\"./Errors\");_Errors=function _Errors(){return data;};return data;}function _Project(){var data=require(\"./Project\");_Project=function _Project(){return data;};return data;}function _getConfig(){var data=require(\"./getConfig\");_getConfig=function _getConfig(){return data;};return data;}function _getFullName(){var data=require(\"./getFullName\");_getFullName=function _getFullName(){return data;};return data;}function _withConfigPlugins(){var data=require(\"./plugins/withConfigPlugins\");_withConfigPlugins=function _withConfigPlugins(){return data;};return data;}function _withInternal(){var data=require(\"./plugins/withInternal\");_withInternal=function _withInternal(){return data;};return data;}function _resolvePackageJson(){var data=require(\"./resolvePackageJson\");_resolvePackageJson=function _resolvePackageJson(){return data;};return data;}var _Config=require(\"./Config.types\");Object.keys(_Config).forEach(function(key){if(key===\"default\"||key===\"__esModule\")return;if(Object.prototype.hasOwnProperty.call(_exportNames,key))return;if(key in exports&&exports[key]===_Config[key])return;Object.defineProperty(exports,key,{enumerable:true,get:function get(){return _Config[key];}});});function _isLegacyImportsEnabled(){var data=require(\"./isLegacyImportsEnabled\");_isLegacyImportsEnabled=function _isLegacyImportsEnabled(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * If a config has an `expo` object then that will be used as the config.\n * This method reduces out other top level values if an `expo` object exists.\n *\n * @param config Input config object to reduce\n */function reduceExpoObject(config){var _config$expo;if(!config)return config===undefined?null:config;var _ref=(_config$expo=config.expo)!==null&&_config$expo!==void 0?_config$expo:config,mods=_ref.mods,expo=_objectWithoutProperties(_ref,_excluded);return{expo:expo,mods:mods};}/**\n * Get all platforms that a project is currently capable of running.\n *\n * @param projectRoot\n * @param exp\n */function getSupportedPlatforms(projectRoot){var platforms=[];if(_resolveFrom()[\"default\"].silent(projectRoot,'react-native')){platforms.push('ios','android');}if(_resolveFrom()[\"default\"].silent(projectRoot,'react-native-web')){platforms.push('web');}return platforms;}/**\n * Evaluate the config for an Expo project.\n * If a function is exported from the `app.config.js` then a partial config will be passed as an argument.\n * The partial config is composed from any existing app.json, and certain fields from the `package.json` like name and description.\n *\n * If options.isPublicConfig is true, the Expo config will include only public-facing options (omitting private keys).\n * The resulting config should be suitable for hosting or embedding in a publicly readable location.\n *\n * **Example**\n * ```js\n * module.exports = function({ config }) {\n *   // mutate the config before returning it.\n *   config.slug = 'new slug'\n *   return { expo: config };\n * }\n * ```\n *\n * **Supports**\n * - `app.config.ts`\n * - `app.config.js`\n * - `app.config.json`\n * - `app.json`\n *\n * @param projectRoot the root folder containing all of your application code\n * @param options enforce criteria for a project config\n */function getConfig(projectRoot){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var paths=getConfigFilePaths(projectRoot);var rawStaticConfig=paths.staticConfigPath?(0,_getConfig().getStaticConfig)(paths.staticConfigPath):null;// For legacy reasons, always return an object.\nvar rootConfig=rawStaticConfig||{};var staticConfig=reduceExpoObject(rawStaticConfig)||{};// Can only change the package.json location if an app.json or app.config.json exists\nvar _getPackageJsonAndPat=getPackageJsonAndPath(projectRoot),_getPackageJsonAndPat2=_slicedToArray(_getPackageJsonAndPat,2),packageJson=_getPackageJsonAndPat2[0],packageJsonPath=_getPackageJsonAndPat2[1];function fillAndReturnConfig(config,dynamicConfigObjectType){var configWithDefaultValues=_objectSpread(_objectSpread({},ensureConfigHasDefaultValues({projectRoot:projectRoot,exp:config.expo,pkg:packageJson,skipSDKVersionRequirement:options.skipSDKVersionRequirement,paths:paths,packageJsonPath:packageJsonPath})),{},{mods:config.mods,dynamicConfigObjectType:dynamicConfigObjectType,rootConfig:rootConfig,dynamicConfigPath:paths.dynamicConfigPath,staticConfigPath:paths.staticConfigPath});if(options.isModdedConfig){var _config$mods;// @ts-ignore: Add the mods back to the object.\nconfigWithDefaultValues.exp.mods=(_config$mods=config.mods)!==null&&_config$mods!==void 0?_config$mods:null;}// Apply static json plugins, should be done after _internal\nconfigWithDefaultValues.exp=(0,_withConfigPlugins().withConfigPlugins)(configWithDefaultValues.exp,!!options.skipPlugins);if(!options.isModdedConfig){// @ts-ignore: Delete mods added by static plugins when they won't have a chance to be evaluated\ndelete configWithDefaultValues.exp.mods;}if(options.isPublicConfig){var _configWithDefaultVal,_configWithDefaultVal2,_configWithDefaultVal3,_configWithDefaultVal4;// Remove internal values with references to user's file paths from the public config.\ndelete configWithDefaultValues.exp._internal;if(configWithDefaultValues.exp.hooks){delete configWithDefaultValues.exp.hooks;}if((_configWithDefaultVal=configWithDefaultValues.exp.ios)!==null&&_configWithDefaultVal!==void 0&&_configWithDefaultVal.config){delete configWithDefaultValues.exp.ios.config;}if((_configWithDefaultVal2=configWithDefaultValues.exp.android)!==null&&_configWithDefaultVal2!==void 0&&_configWithDefaultVal2.config){delete configWithDefaultValues.exp.android.config;}// These value will be overwritten when the manifest is being served from the host (i.e. not completely accurate).\n// @ts-ignore: currentFullName not on type yet.\nconfigWithDefaultValues.exp.currentFullName=(0,_getFullName().getFullName)(configWithDefaultValues.exp);// @ts-ignore: originalFullName not on type yet.\nconfigWithDefaultValues.exp.originalFullName=(0,_getFullName().getFullName)(configWithDefaultValues.exp);(_configWithDefaultVal3=configWithDefaultValues.exp.updates)===null||_configWithDefaultVal3===void 0?true:delete _configWithDefaultVal3.codeSigningCertificate;(_configWithDefaultVal4=configWithDefaultValues.exp.updates)===null||_configWithDefaultVal4===void 0?true:delete _configWithDefaultVal4.codeSigningMetadata;}return configWithDefaultValues;}// Fill in the static config\nfunction getContextConfig(config){return ensureConfigHasDefaultValues({projectRoot:projectRoot,exp:config.expo,pkg:packageJson,skipSDKVersionRequirement:true,paths:paths,packageJsonPath:packageJsonPath}).exp;}if(paths.dynamicConfigPath){// No app.config.json or app.json but app.config.js\nvar _ref2=(0,_getConfig().getDynamicConfig)(paths.dynamicConfigPath,{projectRoot:projectRoot,staticConfigPath:paths.staticConfigPath,packageJsonPath:packageJsonPath,config:getContextConfig(staticConfig)}),exportedObjectType=_ref2.exportedObjectType,rawDynamicConfig=_ref2.config;// Allow for the app.config.js to `export default null;`\n// Use `dynamicConfigPath` to detect if a dynamic config exists.\nvar dynamicConfig=reduceExpoObject(rawDynamicConfig)||{};return fillAndReturnConfig(dynamicConfig,exportedObjectType);}// No app.config.js but json or no config\nreturn fillAndReturnConfig(staticConfig||{},null);}function getPackageJson(projectRoot){var _getPackageJsonAndPat3=getPackageJsonAndPath(projectRoot),_getPackageJsonAndPat4=_slicedToArray(_getPackageJsonAndPat3,1),pkg=_getPackageJsonAndPat4[0];return pkg;}function getPackageJsonAndPath(projectRoot){var packageJsonPath=(0,_resolvePackageJson().getRootPackageJsonPath)(projectRoot);return[_jsonFile()[\"default\"].read(packageJsonPath),packageJsonPath];}function readConfigJson(projectRoot){var skipValidation=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var skipSDKVersionRequirement=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var paths=getConfigFilePaths(projectRoot);var rawStaticConfig=paths.staticConfigPath?(0,_getConfig().getStaticConfig)(paths.staticConfigPath):null;var getConfigName=function getConfigName(){if(paths.staticConfigPath)return\" `\".concat(_path()[\"default\"].basename(paths.staticConfigPath),\"`\");return'';};var outputRootConfig=rawStaticConfig;if(outputRootConfig===null||typeof outputRootConfig!=='object'){if(skipValidation){outputRootConfig={expo:{}};}else{throw new(_Errors().ConfigError)(\"Project at path \".concat(_path()[\"default\"].resolve(projectRoot),\" does not contain a valid Expo config\").concat(getConfigName()),'NOT_OBJECT');}}var exp=outputRootConfig.expo;if(exp===null||typeof exp!=='object'){throw new(_Errors().ConfigError)(\"Property 'expo' in\".concat(getConfigName(),\" for project at path \").concat(_path()[\"default\"].resolve(projectRoot),\" is not an object. Please make sure\").concat(getConfigName(),\" includes a managed Expo app config like this: \").concat(APP_JSON_EXAMPLE),'NO_EXPO');}exp=_objectSpread({},exp);var _getPackageJsonAndPat5=getPackageJsonAndPath(projectRoot),_getPackageJsonAndPat6=_slicedToArray(_getPackageJsonAndPat5,2),pkg=_getPackageJsonAndPat6[0],packageJsonPath=_getPackageJsonAndPat6[1];return _objectSpread(_objectSpread({},ensureConfigHasDefaultValues({projectRoot:projectRoot,exp:exp,pkg:pkg,skipSDKVersionRequirement:skipSDKVersionRequirement,paths:paths,packageJsonPath:packageJsonPath})),{},{mods:null,dynamicConfigObjectType:null,rootConfig:_objectSpread({},outputRootConfig)},paths);}/**\n * Get the static and dynamic config paths for a project. Also accounts for custom paths.\n *\n * @param projectRoot\n */function getConfigFilePaths(projectRoot){var customPaths=getCustomConfigFilePaths(projectRoot);if(customPaths){return customPaths;}return{dynamicConfigPath:getDynamicConfigFilePath(projectRoot),staticConfigPath:getStaticConfigFilePath(projectRoot)};}function getCustomConfigFilePaths(projectRoot){if(!customConfigPaths[projectRoot]){return null;}// If the user picks a custom config path, we will only use that and skip searching for a secondary config.\nif(isDynamicFilePath(customConfigPaths[projectRoot])){return{dynamicConfigPath:customConfigPaths[projectRoot],staticConfigPath:null};}// Anything that's not js or ts will be treated as json.\nreturn{staticConfigPath:customConfigPaths[projectRoot],dynamicConfigPath:null};}function getDynamicConfigFilePath(projectRoot){for(var _i=0,_arr=['app.config.ts','app.config.js'];_i<_arr.length;_i++){var fileName=_arr[_i];var configPath=_path()[\"default\"].join(projectRoot,fileName);if(_fs()[\"default\"].existsSync(configPath)){return configPath;}}return null;}function getStaticConfigFilePath(projectRoot){for(var _i2=0,_arr2=['app.config.json','app.json'];_i2<_arr2.length;_i2++){var fileName=_arr2[_i2];var configPath=_path()[\"default\"].join(projectRoot,fileName);if(_fs()[\"default\"].existsSync(configPath)){return configPath;}}return null;}// TODO: This should account for dynamic configs\nfunction findConfigFile(projectRoot){var configPath;// Check for a custom config path first.\nif(customConfigPaths[projectRoot]){configPath=customConfigPaths[projectRoot];// We shouldn't verify if the file exists because\n// the user manually specified that this path should be used.\nreturn{configPath:configPath,configName:_path()[\"default\"].basename(configPath),configNamespace:'expo'};}else{// app.config.json takes higher priority over app.json\nconfigPath=_path()[\"default\"].join(projectRoot,'app.config.json');if(!_fs()[\"default\"].existsSync(configPath)){configPath=_path()[\"default\"].join(projectRoot,'app.json');}}return{configPath:configPath,configName:_path()[\"default\"].basename(configPath),configNamespace:'expo'};}// TODO: deprecate\nfunction configFilename(projectRoot){return findConfigFile(projectRoot).configName;}function readExpRcAsync(_x){return _readExpRcAsync.apply(this,arguments);}function _readExpRcAsync(){_readExpRcAsync=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(projectRoot){var expRcPath;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:expRcPath=_path()[\"default\"].join(projectRoot,'.exprc');_context.next=3;return _jsonFile()[\"default\"].readAsync(expRcPath,{json5:true,cantReadFileDefault:{}});case 3:return _context.abrupt(\"return\",_context.sent);case 4:case\"end\":return _context.stop();}}},_callee);}));return _readExpRcAsync.apply(this,arguments);}var customConfigPaths={};function resetCustomConfigPaths(){for(var _i3=0,_Object$keys=Object.keys(customConfigPaths);_i3<_Object$keys.length;_i3++){var key=_Object$keys[_i3];delete customConfigPaths[key];}}function setCustomConfigPath(projectRoot,configPath){customConfigPaths[projectRoot]=configPath;}/**\n * Attempt to modify an Expo project config.\n * This will only fully work if the project is using static configs only.\n * Otherwise 'warn' | 'fail' will return with a message about why the config couldn't be updated.\n * The potentially modified config object will be returned for testing purposes.\n *\n * @param projectRoot\n * @param modifications modifications to make to an existing config\n * @param readOptions options for reading the current config file\n * @param writeOptions If true, the static config file will not be rewritten\n */function modifyConfigAsync(_x2,_x3){return _modifyConfigAsync.apply(this,arguments);}function _modifyConfigAsync(){_modifyConfigAsync=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(projectRoot,modifications){var readOptions,writeOptions,config,outputConfig,_args2=arguments;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:readOptions=_args2.length>2&&_args2[2]!==undefined?_args2[2]:{};writeOptions=_args2.length>3&&_args2[3]!==undefined?_args2[3]:{};config=getConfig(projectRoot,readOptions);if(!config.dynamicConfigPath){_context2.next=7;break;}return _context2.abrupt(\"return\",{type:'warn',message:\"Cannot automatically write to dynamic config at: \".concat(_path()[\"default\"].relative(projectRoot,config.dynamicConfigPath)),config:null});case 7:if(!config.staticConfigPath){_context2.next=13;break;}// Static with no dynamic config, this means we can append to the config automatically.\n// If the config has an expo object (app.json) then append the options to that object.\nif(config.rootConfig.expo){outputConfig=_objectSpread(_objectSpread({},config.rootConfig),{},{expo:_objectSpread(_objectSpread({},config.rootConfig.expo),modifications)});}else{// Otherwise (app.config.json) just add the config modification to the top most level.\noutputConfig=_objectSpread(_objectSpread({},config.rootConfig),modifications);}if(writeOptions.dryRun){_context2.next=12;break;}_context2.next=12;return _jsonFile()[\"default\"].writeAsync(config.staticConfigPath,outputConfig,{json5:false});case 12:return _context2.abrupt(\"return\",{type:'success',config:outputConfig});case 13:return _context2.abrupt(\"return\",{type:'fail',message:'No config exists',config:null});case 14:case\"end\":return _context2.stop();}}},_callee2);}));return _modifyConfigAsync.apply(this,arguments);}var APP_JSON_EXAMPLE=JSON.stringify({expo:{name:'My app',slug:'my-app',sdkVersion:'...'}});function ensureConfigHasDefaultValues(_ref3){var projectRoot=_ref3.projectRoot,exp=_ref3.exp,pkg=_ref3.pkg,paths=_ref3.paths,packageJsonPath=_ref3.packageJsonPath,_ref3$skipSDKVersionR=_ref3.skipSDKVersionRequirement,skipSDKVersionRequirement=_ref3$skipSDKVersionR===void 0?false:_ref3$skipSDKVersionR;var _exp$name,_exp$slug,_exp$version;if(!exp){exp={};}exp=(0,_withInternal().withInternal)(exp,_objectSpread(_objectSpread({projectRoot:projectRoot},paths!==null&&paths!==void 0?paths:{}),{},{packageJsonPath:packageJsonPath}));// Defaults for package.json fields\nvar pkgName=typeof pkg.name==='string'?pkg.name:_path()[\"default\"].basename(projectRoot);var pkgVersion=typeof pkg.version==='string'?pkg.version:'1.0.0';var pkgWithDefaults=_objectSpread(_objectSpread({},pkg),{},{name:pkgName,version:pkgVersion});// Defaults for app.json/app.config.js fields\nvar name=(_exp$name=exp.name)!==null&&_exp$name!==void 0?_exp$name:pkgName;var slug=(_exp$slug=exp.slug)!==null&&_exp$slug!==void 0?_exp$slug:(0,_slugify()[\"default\"])(name.toLowerCase());var version=(_exp$version=exp.version)!==null&&_exp$version!==void 0?_exp$version:pkgVersion;var description=exp.description;if(!description&&typeof pkg.description==='string'){description=pkg.description;}var expWithDefaults=_objectSpread(_objectSpread({},exp),{},{name:name,slug:slug,version:version,description:description});var sdkVersion;try{sdkVersion=(0,_Project().getExpoSDKVersion)(projectRoot,expWithDefaults);}catch(error){if(!skipSDKVersionRequirement)throw error;}var platforms=exp.platforms;if(!platforms){platforms=getSupportedPlatforms(projectRoot);}return{exp:_objectSpread(_objectSpread({},expWithDefaults),{},{sdkVersion:sdkVersion,platforms:platforms}),pkg:pkgWithDefaults};}function writeConfigJsonAsync(_x4,_x5){return _writeConfigJsonAsync.apply(this,arguments);}function _writeConfigJsonAsync(){_writeConfigJsonAsync=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(projectRoot,options){var paths,_readConfigJson,exp,pkg,rootConfig,dynamicConfigObjectType;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:paths=getConfigFilePaths(projectRoot);_readConfigJson=readConfigJson(projectRoot),exp=_readConfigJson.exp,pkg=_readConfigJson.pkg,rootConfig=_readConfigJson.rootConfig,dynamicConfigObjectType=_readConfigJson.dynamicConfigObjectType;exp=_objectSpread(_objectSpread({},rootConfig.expo),options);rootConfig=_objectSpread(_objectSpread({},rootConfig),{},{expo:exp});if(!paths.staticConfigPath){_context3.next=9;break;}_context3.next=7;return _jsonFile()[\"default\"].writeAsync(paths.staticConfigPath,rootConfig,{json5:false});case 7:_context3.next=10;break;case 9:console.log('Failed to write to config: ',options);case 10:return _context3.abrupt(\"return\",_objectSpread({exp:exp,pkg:pkg,rootConfig:rootConfig,dynamicConfigObjectType:dynamicConfigObjectType},paths));case 11:case\"end\":return _context3.stop();}}},_callee3);}));return _writeConfigJsonAsync.apply(this,arguments);}var DEFAULT_BUILD_PATH=\"web-build\";function getWebOutputPath(){var config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var _expo$web,_expo$web$build;if(process.env.WEBPACK_BUILD_OUTPUT_PATH){return process.env.WEBPACK_BUILD_OUTPUT_PATH;}var expo=config.expo||config||{};return(expo===null||expo===void 0?void 0:(_expo$web=expo.web)===null||_expo$web===void 0?void 0:(_expo$web$build=_expo$web.build)===null||_expo$web$build===void 0?void 0:_expo$web$build.output)||DEFAULT_BUILD_PATH;}function getNameFromConfig(){var exp=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// For RN CLI support\nvar appManifest=exp.expo||exp;var _appManifest$web=appManifest.web,web=_appManifest$web===void 0?{}:_appManifest$web;// rn-cli apps use a displayName value as well.\nvar appName=exp.displayName||appManifest.displayName||appManifest.name;var webName=web.name||appName;return{appName:appName,webName:webName};}function getDefaultTarget(projectRoot,exp){var _exp;(_exp=exp)!==null&&_exp!==void 0?_exp:exp=getConfig(projectRoot,{skipSDKVersionRequirement:true}).exp;// before SDK 37, always default to managed to preserve previous behavior\nif(exp.sdkVersion&&exp.sdkVersion!=='UNVERSIONED'&&_semver()[\"default\"].lt(exp.sdkVersion,'37.0.0')){return'managed';}return isBareWorkflowProject(projectRoot)?'bare':'managed';}function isBareWorkflowProject(projectRoot){var _getPackageJsonAndPat7=getPackageJsonAndPath(projectRoot),_getPackageJsonAndPat8=_slicedToArray(_getPackageJsonAndPat7,1),pkg=_getPackageJsonAndPat8[0];if(pkg.dependencies&&pkg.dependencies.expokit){return false;}var xcodeprojFiles=(0,_glob().sync)('ios/**/*.xcodeproj',{absolute:true,cwd:projectRoot});if(xcodeprojFiles.length){return true;}var gradleFiles=(0,_glob().sync)('android/**/*.gradle',{absolute:true,cwd:projectRoot});if(gradleFiles.length){return true;}return false;}/**\n * true if the file is .js or .ts\n *\n * @param filePath\n */function isDynamicFilePath(filePath){return!!filePath.match(/\\.[j|t]s$/);}/**\n * Return a useful name describing the project config.\n * - dynamic: app.config.js\n * - static: app.json\n * - custom path app config relative to root folder\n * - both: app.config.js or app.json\n */function getProjectConfigDescription(projectRoot){var paths=getConfigFilePaths(projectRoot);return getProjectConfigDescriptionWithPaths(projectRoot,paths);}/**\n * Returns a string describing the configurations used for the given project root.\n * Will return null if no config is found.\n *\n * @param projectRoot\n * @param projectConfig\n */function getProjectConfigDescriptionWithPaths(projectRoot,projectConfig){if(projectConfig.dynamicConfigPath){var relativeDynamicConfigPath=_path()[\"default\"].relative(projectRoot,projectConfig.dynamicConfigPath);if(projectConfig.staticConfigPath){return\"\".concat(relativeDynamicConfigPath,\" or \").concat(_path()[\"default\"].relative(projectRoot,projectConfig.staticConfigPath));}return relativeDynamicConfigPath;}else if(projectConfig.staticConfigPath){return _path()[\"default\"].relative(projectRoot,projectConfig.staticConfigPath);}// If a config doesn't exist, our tooling will generate a static app.json\nreturn'app.json';}","map":{"version":3,"sources":["../src/Config.ts"],"names":["config","expo","mods","platforms","resolveFrom","options","paths","getConfigFilePaths","rawStaticConfig","rootConfig","staticConfig","reduceExpoObject","getPackageJsonAndPath","configWithDefaultValues","ensureConfigHasDefaultValues","projectRoot","exp","pkg","skipSDKVersionRequirement","packageJsonPath","dynamicConfigObjectType","dynamicConfigPath","staticConfigPath","rawDynamicConfig","getContextConfig","dynamicConfig","fillAndReturnConfig","JsonFile","skipValidation","getConfigName","path","outputRootConfig","ConfigError","customPaths","getCustomConfigFilePaths","getDynamicConfigFilePath","getStaticConfigFilePath","customConfigPaths","isDynamicFilePath","fileName","configPath","fs","configName","configNamespace","findConfigFile","expRcPath","json5","cantReadFileDefault","key","Object","readOptions","writeOptions","getConfig","type","message","outputConfig","modifications","APP_JSON_EXAMPLE","name","slug","sdkVersion","pkgName","pkgVersion","pkgWithDefaults","version","description","expWithDefaults","getSupportedPlatforms","readConfigJson","console","DEFAULT_BUILD_PATH","process","appManifest","web","appName","webName","semver","isBareWorkflowProject","xcodeprojFiles","absolute","cwd","gradleFiles","filePath","getProjectConfigDescriptionWithPaths","projectConfig","relativeDynamicConfigPath"],"mappings":"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","sourcesContent":["import { ModConfig } from '@expo/config-plugins';\nimport JsonFile, { JSONObject } from '@expo/json-file';\nimport fs from 'fs';\nimport { sync as globSync } from 'glob';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\nimport semver from 'semver';\nimport slugify from 'slugify';\n\nimport {\n  AppJSONConfig,\n  ConfigFilePaths,\n  ExpoConfig,\n  ExpRc,\n  GetConfigOptions,\n  PackageJSONConfig,\n  Platform,\n  ProjectConfig,\n  ProjectTarget,\n  WriteConfigOptions,\n} from './Config.types';\nimport { ConfigError } from './Errors';\nimport { getExpoSDKVersion } from './Project';\nimport { getDynamicConfig, getStaticConfig } from './getConfig';\nimport { getFullName } from './getFullName';\nimport { withConfigPlugins } from './plugins/withConfigPlugins';\nimport { withInternal } from './plugins/withInternal';\nimport { getRootPackageJsonPath } from './resolvePackageJson';\n\ntype SplitConfigs = { expo: ExpoConfig; mods: ModConfig };\n\n/**\n * If a config has an `expo` object then that will be used as the config.\n * This method reduces out other top level values if an `expo` object exists.\n *\n * @param config Input config object to reduce\n */\nfunction reduceExpoObject(config?: any): SplitConfigs {\n  if (!config) return config === undefined ? null : config;\n\n  const { mods, ...expo } = config.expo ?? config;\n\n  return {\n    expo,\n    mods,\n  };\n}\n\n/**\n * Get all platforms that a project is currently capable of running.\n *\n * @param projectRoot\n * @param exp\n */\nfunction getSupportedPlatforms(projectRoot: string): Platform[] {\n  const platforms: Platform[] = [];\n  if (resolveFrom.silent(projectRoot, 'react-native')) {\n    platforms.push('ios', 'android');\n  }\n  if (resolveFrom.silent(projectRoot, 'react-native-web')) {\n    platforms.push('web');\n  }\n  return platforms;\n}\n\n/**\n * Evaluate the config for an Expo project.\n * If a function is exported from the `app.config.js` then a partial config will be passed as an argument.\n * The partial config is composed from any existing app.json, and certain fields from the `package.json` like name and description.\n *\n * If options.isPublicConfig is true, the Expo config will include only public-facing options (omitting private keys).\n * The resulting config should be suitable for hosting or embedding in a publicly readable location.\n *\n * **Example**\n * ```js\n * module.exports = function({ config }) {\n *   // mutate the config before returning it.\n *   config.slug = 'new slug'\n *   return { expo: config };\n * }\n * ```\n *\n * **Supports**\n * - `app.config.ts`\n * - `app.config.js`\n * - `app.config.json`\n * - `app.json`\n *\n * @param projectRoot the root folder containing all of your application code\n * @param options enforce criteria for a project config\n */\nexport function getConfig(projectRoot: string, options: GetConfigOptions = {}): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n  // For legacy reasons, always return an object.\n  const rootConfig = (rawStaticConfig || {}) as AppJSONConfig;\n  const staticConfig = reduceExpoObject(rawStaticConfig) || {};\n\n  // Can only change the package.json location if an app.json or app.config.json exists\n  const [packageJson, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  function fillAndReturnConfig(config: SplitConfigs, dynamicConfigObjectType: string | null) {\n    const configWithDefaultValues = {\n      ...ensureConfigHasDefaultValues({\n        projectRoot,\n        exp: config.expo,\n        pkg: packageJson,\n        skipSDKVersionRequirement: options.skipSDKVersionRequirement,\n        paths,\n        packageJsonPath,\n      }),\n      mods: config.mods,\n      dynamicConfigObjectType,\n      rootConfig,\n      dynamicConfigPath: paths.dynamicConfigPath,\n      staticConfigPath: paths.staticConfigPath,\n    };\n\n    if (options.isModdedConfig) {\n      // @ts-ignore: Add the mods back to the object.\n      configWithDefaultValues.exp.mods = config.mods ?? null;\n    }\n\n    // Apply static json plugins, should be done after _internal\n    configWithDefaultValues.exp = withConfigPlugins(\n      configWithDefaultValues.exp,\n      !!options.skipPlugins\n    );\n\n    if (!options.isModdedConfig) {\n      // @ts-ignore: Delete mods added by static plugins when they won't have a chance to be evaluated\n      delete configWithDefaultValues.exp.mods;\n    }\n\n    if (options.isPublicConfig) {\n      // Remove internal values with references to user's file paths from the public config.\n      delete configWithDefaultValues.exp._internal;\n\n      if (configWithDefaultValues.exp.hooks) {\n        delete configWithDefaultValues.exp.hooks;\n      }\n      if (configWithDefaultValues.exp.ios?.config) {\n        delete configWithDefaultValues.exp.ios.config;\n      }\n      if (configWithDefaultValues.exp.android?.config) {\n        delete configWithDefaultValues.exp.android.config;\n      }\n\n      // These value will be overwritten when the manifest is being served from the host (i.e. not completely accurate).\n      // @ts-ignore: currentFullName not on type yet.\n      configWithDefaultValues.exp.currentFullName = getFullName(configWithDefaultValues.exp);\n      // @ts-ignore: originalFullName not on type yet.\n      configWithDefaultValues.exp.originalFullName = getFullName(configWithDefaultValues.exp);\n\n      delete configWithDefaultValues.exp.updates?.codeSigningCertificate;\n      delete configWithDefaultValues.exp.updates?.codeSigningMetadata;\n    }\n\n    return configWithDefaultValues;\n  }\n\n  // Fill in the static config\n  function getContextConfig(config: SplitConfigs) {\n    return ensureConfigHasDefaultValues({\n      projectRoot,\n      exp: config.expo,\n      pkg: packageJson,\n      skipSDKVersionRequirement: true,\n      paths,\n      packageJsonPath,\n    }).exp;\n  }\n\n  if (paths.dynamicConfigPath) {\n    // No app.config.json or app.json but app.config.js\n    const { exportedObjectType, config: rawDynamicConfig } = getDynamicConfig(\n      paths.dynamicConfigPath,\n      {\n        projectRoot,\n        staticConfigPath: paths.staticConfigPath,\n        packageJsonPath,\n        config: getContextConfig(staticConfig),\n      }\n    );\n    // Allow for the app.config.js to `export default null;`\n    // Use `dynamicConfigPath` to detect if a dynamic config exists.\n    const dynamicConfig = reduceExpoObject(rawDynamicConfig) || {};\n    return fillAndReturnConfig(dynamicConfig, exportedObjectType);\n  }\n\n  // No app.config.js but json or no config\n  return fillAndReturnConfig(staticConfig || {}, null);\n}\n\nexport function getPackageJson(projectRoot: string): PackageJSONConfig {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n  return pkg;\n}\n\nfunction getPackageJsonAndPath(projectRoot: string): [PackageJSONConfig, string] {\n  const packageJsonPath = getRootPackageJsonPath(projectRoot);\n  return [JsonFile.read(packageJsonPath), packageJsonPath];\n}\n\nexport function readConfigJson(\n  projectRoot: string,\n  skipValidation: boolean = false,\n  skipSDKVersionRequirement: boolean = false\n): ProjectConfig {\n  const paths = getConfigFilePaths(projectRoot);\n\n  const rawStaticConfig = paths.staticConfigPath ? getStaticConfig(paths.staticConfigPath) : null;\n\n  const getConfigName = (): string => {\n    if (paths.staticConfigPath) return ` \\`${path.basename(paths.staticConfigPath)}\\``;\n    return '';\n  };\n\n  let outputRootConfig = rawStaticConfig as JSONObject | null;\n  if (outputRootConfig === null || typeof outputRootConfig !== 'object') {\n    if (skipValidation) {\n      outputRootConfig = { expo: {} };\n    } else {\n      throw new ConfigError(\n        `Project at path ${path.resolve(\n          projectRoot\n        )} does not contain a valid Expo config${getConfigName()}`,\n        'NOT_OBJECT'\n      );\n    }\n  }\n  let exp = outputRootConfig.expo as Partial<ExpoConfig>;\n  if (exp === null || typeof exp !== 'object') {\n    throw new ConfigError(\n      `Property 'expo' in${getConfigName()} for project at path ${path.resolve(\n        projectRoot\n      )} is not an object. Please make sure${getConfigName()} includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`,\n      'NO_EXPO'\n    );\n  }\n\n  exp = { ...exp };\n\n  const [pkg, packageJsonPath] = getPackageJsonAndPath(projectRoot);\n\n  return {\n    ...ensureConfigHasDefaultValues({\n      projectRoot,\n      exp,\n      pkg,\n      skipSDKVersionRequirement,\n      paths,\n      packageJsonPath,\n    }),\n    mods: null,\n    dynamicConfigObjectType: null,\n    rootConfig: { ...outputRootConfig } as AppJSONConfig,\n    ...paths,\n  };\n}\n\n/**\n * Get the static and dynamic config paths for a project. Also accounts for custom paths.\n *\n * @param projectRoot\n */\nexport function getConfigFilePaths(projectRoot: string): ConfigFilePaths {\n  const customPaths = getCustomConfigFilePaths(projectRoot);\n  if (customPaths) {\n    return customPaths;\n  }\n\n  return {\n    dynamicConfigPath: getDynamicConfigFilePath(projectRoot),\n    staticConfigPath: getStaticConfigFilePath(projectRoot),\n  };\n}\n\nfunction getCustomConfigFilePaths(projectRoot: string): ConfigFilePaths | null {\n  if (!customConfigPaths[projectRoot]) {\n    return null;\n  }\n  // If the user picks a custom config path, we will only use that and skip searching for a secondary config.\n  if (isDynamicFilePath(customConfigPaths[projectRoot])) {\n    return {\n      dynamicConfigPath: customConfigPaths[projectRoot],\n      staticConfigPath: null,\n    };\n  }\n  // Anything that's not js or ts will be treated as json.\n  return { staticConfigPath: customConfigPaths[projectRoot], dynamicConfigPath: null };\n}\n\nfunction getDynamicConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.ts', 'app.config.js']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\nfunction getStaticConfigFilePath(projectRoot: string): string | null {\n  for (const fileName of ['app.config.json', 'app.json']) {\n    const configPath = path.join(projectRoot, fileName);\n    if (fs.existsSync(configPath)) {\n      return configPath;\n    }\n  }\n  return null;\n}\n\n// TODO: This should account for dynamic configs\nexport function findConfigFile(\n  projectRoot: string\n): { configPath: string; configName: string; configNamespace: 'expo' } {\n  let configPath: string;\n  // Check for a custom config path first.\n  if (customConfigPaths[projectRoot]) {\n    configPath = customConfigPaths[projectRoot];\n    // We shouldn't verify if the file exists because\n    // the user manually specified that this path should be used.\n    return {\n      configPath,\n      configName: path.basename(configPath),\n      configNamespace: 'expo',\n    };\n  } else {\n    // app.config.json takes higher priority over app.json\n    configPath = path.join(projectRoot, 'app.config.json');\n    if (!fs.existsSync(configPath)) {\n      configPath = path.join(projectRoot, 'app.json');\n    }\n  }\n\n  return {\n    configPath,\n    configName: path.basename(configPath),\n    configNamespace: 'expo',\n  };\n}\n\n// TODO: deprecate\nexport function configFilename(projectRoot: string): string {\n  return findConfigFile(projectRoot).configName;\n}\n\nexport async function readExpRcAsync(projectRoot: string): Promise<ExpRc> {\n  const expRcPath = path.join(projectRoot, '.exprc');\n  return await JsonFile.readAsync(expRcPath, { json5: true, cantReadFileDefault: {} });\n}\n\nconst customConfigPaths: { [projectRoot: string]: string } = {};\n\nexport function resetCustomConfigPaths(): void {\n  for (const key of Object.keys(customConfigPaths)) {\n    delete customConfigPaths[key];\n  }\n}\n\nexport function setCustomConfigPath(projectRoot: string, configPath: string): void {\n  customConfigPaths[projectRoot] = configPath;\n}\n\n/**\n * Attempt to modify an Expo project config.\n * This will only fully work if the project is using static configs only.\n * Otherwise 'warn' | 'fail' will return with a message about why the config couldn't be updated.\n * The potentially modified config object will be returned for testing purposes.\n *\n * @param projectRoot\n * @param modifications modifications to make to an existing config\n * @param readOptions options for reading the current config file\n * @param writeOptions If true, the static config file will not be rewritten\n */\nexport async function modifyConfigAsync(\n  projectRoot: string,\n  modifications: Partial<ExpoConfig>,\n  readOptions: GetConfigOptions = {},\n  writeOptions: WriteConfigOptions = {}\n): Promise<{\n  type: 'success' | 'warn' | 'fail';\n  message?: string;\n  config: AppJSONConfig | null;\n}> {\n  const config = getConfig(projectRoot, readOptions);\n  if (config.dynamicConfigPath) {\n    // We cannot automatically write to a dynamic config.\n    /* Currently we should just use the safest approach possible, informing the user that they'll need to manually modify their dynamic config.\n\n    if (config.staticConfigPath) {\n      // Both a dynamic and a static config exist.\n      if (config.dynamicConfigObjectType === 'function') {\n        // The dynamic config exports a function, this means it possibly extends the static config.\n      } else {\n        // Dynamic config ignores the static config, there isn't a reason to automatically write to it.\n        // Instead we should warn the user to add values to their dynamic config.\n      }\n    }\n    */\n    return {\n      type: 'warn',\n      message: `Cannot automatically write to dynamic config at: ${path.relative(\n        projectRoot,\n        config.dynamicConfigPath\n      )}`,\n      config: null,\n    };\n  } else if (config.staticConfigPath) {\n    // Static with no dynamic config, this means we can append to the config automatically.\n    let outputConfig: AppJSONConfig;\n    // If the config has an expo object (app.json) then append the options to that object.\n    if (config.rootConfig.expo) {\n      outputConfig = {\n        ...config.rootConfig,\n        expo: { ...config.rootConfig.expo, ...modifications },\n      };\n    } else {\n      // Otherwise (app.config.json) just add the config modification to the top most level.\n      outputConfig = { ...config.rootConfig, ...modifications };\n    }\n    if (!writeOptions.dryRun) {\n      await JsonFile.writeAsync(config.staticConfigPath, outputConfig, { json5: false });\n    }\n    return { type: 'success', config: outputConfig };\n  }\n\n  return { type: 'fail', message: 'No config exists', config: null };\n}\n\nconst APP_JSON_EXAMPLE = JSON.stringify({\n  expo: {\n    name: 'My app',\n    slug: 'my-app',\n    sdkVersion: '...',\n  },\n});\n\nfunction ensureConfigHasDefaultValues({\n  projectRoot,\n  exp,\n  pkg,\n  paths,\n  packageJsonPath,\n  skipSDKVersionRequirement = false,\n}: {\n  projectRoot: string;\n  exp: Partial<ExpoConfig> | null;\n  pkg: JSONObject;\n  skipSDKVersionRequirement?: boolean;\n  paths?: ConfigFilePaths;\n  packageJsonPath?: string;\n}): { exp: ExpoConfig; pkg: PackageJSONConfig } {\n  if (!exp) {\n    exp = {};\n  }\n  exp = withInternal(exp as any, {\n    projectRoot,\n    ...(paths ?? {}),\n    packageJsonPath,\n  });\n  // Defaults for package.json fields\n  const pkgName = typeof pkg.name === 'string' ? pkg.name : path.basename(projectRoot);\n  const pkgVersion = typeof pkg.version === 'string' ? pkg.version : '1.0.0';\n\n  const pkgWithDefaults = { ...pkg, name: pkgName, version: pkgVersion };\n\n  // Defaults for app.json/app.config.js fields\n  const name = exp.name ?? pkgName;\n  const slug = exp.slug ?? slugify(name.toLowerCase());\n  const version = exp.version ?? pkgVersion;\n  let description = exp.description;\n  if (!description && typeof pkg.description === 'string') {\n    description = pkg.description;\n  }\n\n  const expWithDefaults = { ...exp, name, slug, version, description };\n\n  let sdkVersion;\n  try {\n    sdkVersion = getExpoSDKVersion(projectRoot, expWithDefaults);\n  } catch (error) {\n    if (!skipSDKVersionRequirement) throw error;\n  }\n\n  let platforms = exp.platforms;\n  if (!platforms) {\n    platforms = getSupportedPlatforms(projectRoot);\n  }\n\n  return {\n    exp: { ...expWithDefaults, sdkVersion, platforms },\n    pkg: pkgWithDefaults,\n  };\n}\n\nexport async function writeConfigJsonAsync(\n  projectRoot: string,\n  options: object\n): Promise<ProjectConfig> {\n  const paths = getConfigFilePaths(projectRoot);\n  let { exp, pkg, rootConfig, dynamicConfigObjectType } = readConfigJson(projectRoot);\n  exp = { ...rootConfig.expo, ...options };\n  rootConfig = { ...rootConfig, expo: exp };\n\n  if (paths.staticConfigPath) {\n    await JsonFile.writeAsync(paths.staticConfigPath, rootConfig, { json5: false });\n  } else {\n    console.log('Failed to write to config: ', options);\n  }\n\n  return {\n    exp,\n    pkg,\n    rootConfig,\n    dynamicConfigObjectType,\n    ...paths,\n  };\n}\nconst DEFAULT_BUILD_PATH = `web-build`;\n\nexport function getWebOutputPath(config: { [key: string]: any } = {}): string {\n  if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {\n    return process.env.WEBPACK_BUILD_OUTPUT_PATH;\n  }\n  const expo = config.expo || config || {};\n  return expo?.web?.build?.output || DEFAULT_BUILD_PATH;\n}\n\nexport function getNameFromConfig(\n  exp: Record<string, any> = {}\n): { appName?: string; webName?: string } {\n  // For RN CLI support\n  const appManifest = exp.expo || exp;\n  const { web = {} } = appManifest;\n\n  // rn-cli apps use a displayName value as well.\n  const appName = exp.displayName || appManifest.displayName || appManifest.name;\n  const webName = web.name || appName;\n\n  return {\n    appName,\n    webName,\n  };\n}\n\nexport function getDefaultTarget(\n  projectRoot: string,\n  exp?: Pick<ExpoConfig, 'sdkVersion'>\n): ProjectTarget {\n  exp ??= getConfig(projectRoot, { skipSDKVersionRequirement: true }).exp;\n\n  // before SDK 37, always default to managed to preserve previous behavior\n  if (exp.sdkVersion && exp.sdkVersion !== 'UNVERSIONED' && semver.lt(exp.sdkVersion, '37.0.0')) {\n    return 'managed';\n  }\n  return isBareWorkflowProject(projectRoot) ? 'bare' : 'managed';\n}\n\nfunction isBareWorkflowProject(projectRoot: string): boolean {\n  const [pkg] = getPackageJsonAndPath(projectRoot);\n\n  if (pkg.dependencies && pkg.dependencies.expokit) {\n    return false;\n  }\n\n  const xcodeprojFiles = globSync('ios/**/*.xcodeproj', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (xcodeprojFiles.length) {\n    return true;\n  }\n  const gradleFiles = globSync('android/**/*.gradle', {\n    absolute: true,\n    cwd: projectRoot,\n  });\n  if (gradleFiles.length) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * true if the file is .js or .ts\n *\n * @param filePath\n */\nfunction isDynamicFilePath(filePath: string): boolean {\n  return !!filePath.match(/\\.[j|t]s$/);\n}\n\n/**\n * Return a useful name describing the project config.\n * - dynamic: app.config.js\n * - static: app.json\n * - custom path app config relative to root folder\n * - both: app.config.js or app.json\n */\nexport function getProjectConfigDescription(projectRoot: string): string {\n  const paths = getConfigFilePaths(projectRoot);\n  return getProjectConfigDescriptionWithPaths(projectRoot, paths);\n}\n\n/**\n * Returns a string describing the configurations used for the given project root.\n * Will return null if no config is found.\n *\n * @param projectRoot\n * @param projectConfig\n */\nexport function getProjectConfigDescriptionWithPaths(\n  projectRoot: string,\n  projectConfig: ConfigFilePaths\n): string {\n  if (projectConfig.dynamicConfigPath) {\n    const relativeDynamicConfigPath = path.relative(projectRoot, projectConfig.dynamicConfigPath);\n    if (projectConfig.staticConfigPath) {\n      return `${relativeDynamicConfigPath} or ${path.relative(\n        projectRoot,\n        projectConfig.staticConfigPath\n      )}`;\n    }\n    return relativeDynamicConfigPath;\n  } else if (projectConfig.staticConfigPath) {\n    return path.relative(projectRoot, projectConfig.staticConfigPath);\n  }\n  // If a config doesn't exist, our tooling will generate a static app.json\n  return 'app.json';\n}\n\nexport * from './Config.types';\n\nexport { isLegacyImportsEnabled } from './isLegacyImportsEnabled';\n"]},"metadata":{},"sourceType":"script"}