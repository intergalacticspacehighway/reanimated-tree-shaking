{"ast":null,"code":"\"use strict\";var _slicedToArray=require(\"/Users/fernandorojo/Developer/messing/rea-tree/node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.withStaticPlugin=void 0;function _assert(){var data=_interopRequireDefault(require(\"assert\"));_assert=function _assert(){return data;};return data;}function _getenv(){var data=require(\"getenv\");_getenv=function _getenv(){return data;};return data;}function _errors(){var data=require(\"../utils/errors\");_errors=function _errors(){return data;};return data;}function _pluginResolver(){var data=require(\"../utils/plugin-resolver\");_pluginResolver=function _pluginResolver(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}var EXPO_DEBUG=(0,_getenv().boolish)('EXPO_DEBUG',false);// Show all error info related to plugin resolution.\nvar EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS=(0,_getenv().boolish)('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS',false);// Force using the fallback unversioned plugin instead of a local versioned copy,\n// this should only be used for testing the CLI.\nvar EXPO_USE_UNVERSIONED_PLUGINS=(0,_getenv().boolish)('EXPO_USE_UNVERSIONED_PLUGINS',false);function isModuleMissingError(name,error){// @ts-ignore\nif(['MODULE_NOT_FOUND','PLUGIN_NOT_FOUND'].includes(error.code)){return true;}return error.message.includes(\"Cannot find module '\".concat(name,\"'\"));}function isUnexpectedTokenError(error){if(error instanceof SyntaxError||error instanceof _errors().PluginError&&error.code==='INVALID_PLUGIN_IMPORT'){return(// These are the most common errors that'll be thrown when a package isn't transpiled correctly.\n!!error.message.match(/Unexpected token/)||!!error.message.match(/Cannot use import statement/));}return false;}/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n * @param _isLegacyPlugin Used to suppress errors thrown by plugins that are applied automatically\n */var withStaticPlugin=function withStaticPlugin(config,props){var _pluginProps;var projectRoot=props.projectRoot;if(!projectRoot){var _config$_internal;projectRoot=(_config$_internal=config._internal)===null||_config$_internal===void 0?void 0:_config$_internal.projectRoot;(0,_pluginResolver().assertInternalProjectRoot)(projectRoot);}var _ref=(0,_pluginResolver().normalizeStaticPlugin)(props.plugin),_ref2=_slicedToArray(_ref,2),pluginResolve=_ref2[0],pluginProps=_ref2[1];// Ensure no one uses this property by accident.\n(0,_assert()[\"default\"])(!((_pluginProps=pluginProps)!==null&&_pluginProps!==void 0&&_pluginProps._resolverError),\"Plugin property '_resolverError' is a reserved property of `withStaticPlugin`\");var withPlugin;if(// Function was provided, no need to resolve: [withPlugin, {}]\ntypeof pluginResolve==='function'){withPlugin=pluginResolve;}else if(typeof pluginResolve==='string'){try{// Resolve and evaluate plugins.\nwithPlugin=(0,_pluginResolver().resolveConfigPluginFunction)(projectRoot,pluginResolve);// Only force if the project has the versioned plugin, otherwise use default behavior.\n// This helps see which plugins are being skipped.\nif(EXPO_USE_UNVERSIONED_PLUGINS&&!!withPlugin&&!!props._isLegacyPlugin&&!!props.fallback){console.log(\"Force \\\"\".concat(pluginResolve,\"\\\" to unversioned plugin\"));withPlugin=props.fallback;}}catch(error){if(EXPO_DEBUG){if(EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS){// Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\nconsole.log(\"Error resolving plugin \\\"\".concat(pluginResolve,\"\\\"\"));console.log(error);console.log();}else{var shouldMuteWarning=props._isLegacyPlugin&&(isModuleMissingError(pluginResolve,error)||isUnexpectedTokenError(error));if(!shouldMuteWarning){if(isModuleMissingError(pluginResolve,error)){// Prevent causing log spew for basic resolution errors.\nconsole.log(\"Could not find plugin \\\"\".concat(pluginResolve,\"\\\"\"));}else{// Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\nconsole.log(\"Error resolving plugin \\\"\".concat(pluginResolve,\"\\\"\"));console.log(error);console.log();}}}}// TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n// If the static module failed to resolve, attempt to use a fallback.\n// This enables support for built-in plugins with versioned variations living in other packages.\nif(props.fallback){if(!pluginProps)pluginProps={};// Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\npluginProps._resolverError=error;withPlugin=props.fallback;}else{// If no fallback, throw the resolution error.\nthrow error;}}}else{throw new(_errors().PluginError)(\"Plugin is an unexpected type: \".concat(typeof pluginResolve),'INVALID_PLUGIN_TYPE');}// Execute the plugin.\nconfig=withPlugin(config,pluginProps);return config;};exports.withStaticPlugin=withStaticPlugin;","map":{"version":3,"sources":["../../src/plugins/withStaticPlugin.ts"],"names":["EXPO_DEBUG","EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS","EXPO_USE_UNVERSIONED_PLUGINS","error","PluginError","withStaticPlugin","projectRoot","props","config","pluginProps","withPlugin","console","shouldMuteWarning","isModuleMissingError","isUnexpectedTokenError"],"mappings":"wPAAA,QAAA,CAAA,OAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,sBAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CACA,QAAA,CAAA,OAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAA,QAAA,CAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAGA,QAAA,CAAA,OAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CACA,QAAA,CAAA,eAAA,EAAA,CAAA,GAAA,CAAA,IAAA,CAAA,OAAA,CAAA,0BAAA,CAAA,CAAA,eAAA,CAAA,0BAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,IAAA,CAAA,C,qFAMA,GAAMA,CAAAA,UAAU,CAAG,CAAA,EAAA,OAAA,GAAA,OAAA,EAAA,YAAA,CAAnB,KAAmB,CAAnB,CAEA;AACA,GAAMC,CAAAA,iCAAiC,CAAG,CAAA,EAAA,OAAA,GAAA,OAAA,EAAA,mCAAA,CAA1C,KAA0C,CAA1C,CACA;AACA;AACA,GAAMC,CAAAA,4BAA4B,CAAG,CAAA,EAAA,OAAA,GAAA,OAAA,EAAA,8BAAA,CAArC,KAAqC,CAArC,CAEA,QAAA,CAAA,oBAAA,CAAA,IAAA,CAAA,KAAA,CAAmE,CACjE;AACA,GAAI,CAAA,kBAAA,CAAA,kBAAA,EAAA,QAAA,CAAkDC,KAAK,CAA3D,IAAI,CAAJ,CAAmE,CACjE,MAAA,KAAA,CACD,CACD,MAAOA,CAAAA,KAAK,CAALA,OAAAA,CAAAA,QAAAA,+BAAP,IAAOA,MAAP,CACD,CAED,QAAA,CAAA,sBAAA,CAAA,KAAA,CAAuD,CACrD,GACEA,KAAK,WAALA,CAAAA,WAAAA,EACCA,KAAK,WAAYC,CAAAA,OAAAA,GAAjBD,WAAAA,EAAgCA,KAAK,CAALA,IAAAA,GAFnC,uBAAA,CAGE,CACA,MACE;AACA,CAAC,CAACA,KAAK,CAALA,OAAAA,CAAAA,KAAAA,CAAF,kBAAEA,CAAF,EACA,CAAC,CAACA,KAAK,CAALA,OAAAA,CAAAA,KAAAA,CAAAA,6BAAAA,CAHJ,EAKD,CACD,MAAA,MAAA,CACD,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GACO,GAAME,CAAAA,gBAKX,CAAG,QALQA,CAAAA,gBAKR,CAAA,MAAA,CAAA,KAAA,CAAmB,CAAA,GAAA,CAAA,YAAA,CACtB,GAAIC,CAAAA,WAAW,CAAGC,KAAK,CAAvB,WAAA,CACA,GAAI,CAAJ,WAAA,CAAkB,CAAA,GAAA,CAAA,iBAAA,CAChBD,WAAW,CAAA,CAAA,iBAAA,CAAGE,MAAM,CAAT,SAAA,IAAA,IAAA,EAAA,iBAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAGA,iBAAAA,CAAdF,WAAAA,CACA,CAAA,EAAA,eAAA,GAAA,yBAAA,EAAA,WAAA,EACD,CAED,SAAmC,CAAA,EAAA,eAAA,GAAA,qBAAA,EAAsBC,KAAK,CAPxC,MAOa,CAAnC,8BAAI,aAAJ,UAAI,WAAJ,UACA;AACA,CAAA,EAAA,OAAA,aAAA,EACE,EAAA,CAAA,YAAA,CAAA,WAAA,IAAA,IAAA,EAAA,YAAA,GAAA,IAAA,EAAA,EAACE,YAAAA,CADH,cACE,CADF,kFAKA,GAAA,CAAA,UAAA,CAEA,GACE;AACA,MAAA,CAAA,aAAA,GAFF,UAAA,CAGE,CACAC,UAAU,CAAVA,aAAAA,CAJF,CAAA,IAKO,IAAI,MAAA,CAAA,aAAA,GAAJ,QAAA,CAAuC,CAC5C,GAAI,CACF;AACAA,UAAU,CAAG,CAAA,EAAA,eAAA,GAAA,2BAAA,EAAA,WAAA,CAFX,aAEW,CAAbA,CAEA;AACA;AACA,GACER,4BAA4B,EAC5B,CAAC,CADDA,UAAAA,EAEA,CAAC,CAACK,KAAK,CAFPL,eAAAA,EAGA,CAAC,CAACK,KAAK,CAJT,QAAA,CAKE,CACAI,OAAO,CAAPA,GAAAA,mBAAAA,aAAAA,8BACAD,UAAU,CAAGH,KAAK,CAAlBG,QAAAA,CACD,CAdH,CAeE,MAAA,KAAA,CAAmB,CACnB,GAAA,UAAA,CAAgB,CACd,GAAA,iCAAA,CAAuC,CACrC;AACAC,OAAO,CAAPA,GAAAA,oCAAAA,aAAAA,QACAA,OAAO,CAAPA,GAAAA,CAAAA,KAAAA,EACAA,OAAO,CAAPA,GAAAA,GAJF,CAAA,IAKO,CACL,GAAMC,CAAAA,iBAAiB,CACrBL,KAAK,CAALA,eAAAA,GACCM,oBAAoB,CAAA,aAAA,CAApBA,KAAoB,CAApBA,EAA8CC,sBAAsB,CAFvE,KAEuE,CADrEP,CADF,CAGA,GAAI,CAAJ,iBAAA,CAAwB,CACtB,GAAIM,oBAAoB,CAAA,aAAA,CAAxB,KAAwB,CAAxB,CAAgD,CAC9C;AACAF,OAAO,CAAPA,GAAAA,mCAAAA,aAAAA,QAFF,CAAA,IAGO,CACL;AACAA,OAAO,CAAPA,GAAAA,oCAAAA,aAAAA,QACAA,OAAO,CAAPA,GAAAA,CAAAA,KAAAA,EACAA,OAAO,CAAPA,GAAAA,GACD,CACF,CACF,CAtBgB,CAwBnB;AAEA;AACA;AACA,GAAIJ,KAAK,CAAT,QAAA,CAAoB,CAClB,GAAI,CAAJ,WAAA,CAAkBE,WAAW,CADX,EACAA,CAClB;AACAA,WAAW,CAAXA,cAAAA,CAAAA,KAAAA,CACAC,UAAU,CAAGH,KAAK,CAAlBG,QAAAA,CAJF,CAAA,IAKO,CACL;AACA,KAAA,CAAA,KAAA,CACD,CACF,CArDI,CAAA,IAsDA,CACL,KAAM,KAAIN,OAAAA,GAAJ,WAAA,0CAC6B,MAD7B,CAAA,aAAA,EAAN,qBAAM,CAAN,CA5EoB,CAkFtB;AACAI,MAAM,CAAGE,UAAU,CAAA,MAAA,CAAnBF,WAAmB,CAAnBA,CACA,MAAA,CAAA,MAAA,CAzFK,CAAA,C","sourcesContent":["import assert from 'assert';\nimport { boolish } from 'getenv';\n\nimport { ConfigPlugin, StaticPlugin } from '../Plugin.types';\nimport { PluginError } from '../utils/errors';\nimport {\n  assertInternalProjectRoot,\n  normalizeStaticPlugin,\n  resolveConfigPluginFunction,\n} from '../utils/plugin-resolver';\n\nconst EXPO_DEBUG = boolish('EXPO_DEBUG', false);\n\n// Show all error info related to plugin resolution.\nconst EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS = boolish('EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS', false);\n// Force using the fallback unversioned plugin instead of a local versioned copy,\n// this should only be used for testing the CLI.\nconst EXPO_USE_UNVERSIONED_PLUGINS = boolish('EXPO_USE_UNVERSIONED_PLUGINS', false);\n\nfunction isModuleMissingError(name: string, error: Error): boolean {\n  // @ts-ignore\n  if (['MODULE_NOT_FOUND', 'PLUGIN_NOT_FOUND'].includes(error.code)) {\n    return true;\n  }\n  return error.message.includes(`Cannot find module '${name}'`);\n}\n\nfunction isUnexpectedTokenError(error: Error): boolean {\n  if (\n    error instanceof SyntaxError ||\n    (error instanceof PluginError && error.code === 'INVALID_PLUGIN_IMPORT')\n  ) {\n    return (\n      // These are the most common errors that'll be thrown when a package isn't transpiled correctly.\n      !!error.message.match(/Unexpected token/) ||\n      !!error.message.match(/Cannot use import statement/)\n    );\n  }\n  return false;\n}\n\n/**\n * Resolves static module plugin and potentially falls back on a provided plugin if the module cannot be resolved\n *\n * @param config\n * @param fallback Plugin with `_resolverError` explaining why the module couldn't be used\n * @param projectRoot optional project root, fallback to _internal.projectRoot. Used for testing.\n * @param _isLegacyPlugin Used to suppress errors thrown by plugins that are applied automatically\n */\nexport const withStaticPlugin: ConfigPlugin<{\n  plugin: StaticPlugin | ConfigPlugin | string;\n  fallback?: ConfigPlugin<{ _resolverError: Error } & any>;\n  projectRoot?: string;\n  _isLegacyPlugin?: boolean;\n}> = (config, props) => {\n  let projectRoot = props.projectRoot;\n  if (!projectRoot) {\n    projectRoot = config._internal?.projectRoot;\n    assertInternalProjectRoot(projectRoot);\n  }\n\n  let [pluginResolve, pluginProps] = normalizeStaticPlugin(props.plugin);\n  // Ensure no one uses this property by accident.\n  assert(\n    !pluginProps?._resolverError,\n    `Plugin property '_resolverError' is a reserved property of \\`withStaticPlugin\\``\n  );\n\n  let withPlugin: ConfigPlugin<unknown>;\n\n  if (\n    // Function was provided, no need to resolve: [withPlugin, {}]\n    typeof pluginResolve === 'function'\n  ) {\n    withPlugin = pluginResolve;\n  } else if (typeof pluginResolve === 'string') {\n    try {\n      // Resolve and evaluate plugins.\n      withPlugin = resolveConfigPluginFunction(projectRoot, pluginResolve);\n\n      // Only force if the project has the versioned plugin, otherwise use default behavior.\n      // This helps see which plugins are being skipped.\n      if (\n        EXPO_USE_UNVERSIONED_PLUGINS &&\n        !!withPlugin &&\n        !!props._isLegacyPlugin &&\n        !!props.fallback\n      ) {\n        console.log(`Force \"${pluginResolve}\" to unversioned plugin`);\n        withPlugin = props.fallback;\n      }\n    } catch (error: any) {\n      if (EXPO_DEBUG) {\n        if (EXPO_CONFIG_PLUGIN_VERBOSE_ERRORS) {\n          // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n          console.log(`Error resolving plugin \"${pluginResolve}\"`);\n          console.log(error);\n          console.log();\n        } else {\n          const shouldMuteWarning =\n            props._isLegacyPlugin &&\n            (isModuleMissingError(pluginResolve, error) || isUnexpectedTokenError(error));\n          if (!shouldMuteWarning) {\n            if (isModuleMissingError(pluginResolve, error)) {\n              // Prevent causing log spew for basic resolution errors.\n              console.log(`Could not find plugin \"${pluginResolve}\"`);\n            } else {\n              // Log the error in debug mode for plugins with fallbacks (like the Expo managed plugins).\n              console.log(`Error resolving plugin \"${pluginResolve}\"`);\n              console.log(error);\n              console.log();\n            }\n          }\n        }\n      }\n      // TODO: Maybe allow for `PluginError`s to be thrown so external plugins can assert invalid options.\n\n      // If the static module failed to resolve, attempt to use a fallback.\n      // This enables support for built-in plugins with versioned variations living in other packages.\n      if (props.fallback) {\n        if (!pluginProps) pluginProps = {};\n        // Pass this to the fallback plugin for potential warnings about needing to install a versioned package.\n        pluginProps._resolverError = error;\n        withPlugin = props.fallback;\n      } else {\n        // If no fallback, throw the resolution error.\n        throw error;\n      }\n    }\n  } else {\n    throw new PluginError(\n      `Plugin is an unexpected type: ${typeof pluginResolve}`,\n      'INVALID_PLUGIN_TYPE'\n    );\n  }\n\n  // Execute the plugin.\n  config = withPlugin(config, pluginProps);\n  return config;\n};\n"]},"metadata":{},"sourceType":"script"}