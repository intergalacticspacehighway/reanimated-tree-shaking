{"ast":null,"code":"\"use strict\";exports.__esModule=true;exports.attachListeners=attachListeners;exports.addNode=addNode;exports.removeNode=removeNode;exports.terminateResponder=terminateResponder;exports.getResponderNode=getResponderNode;var _ExecutionEnvironment=require(\"fbjs/lib/ExecutionEnvironment\");var _createResponderEvent=_interopRequireDefault(require(\"./createResponderEvent\"));var _ResponderEventTypes=require(\"./ResponderEventTypes\");var _utils=require(\"./utils\");var _ResponderTouchHistoryStore=_interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{\"default\":obj};}/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */ /**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */ /*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */var emptyObject={};/* ------------ IMPLEMENTATION ------------ */var startRegistration=['onStartShouldSetResponderCapture','onStartShouldSetResponder',{bubbles:true}];var moveRegistration=['onMoveShouldSetResponderCapture','onMoveShouldSetResponder',{bubbles:true}];var scrollRegistration=['onScrollShouldSetResponderCapture','onScrollShouldSetResponder',{bubbles:false}];var shouldSetResponderEvents={touchstart:startRegistration,mousedown:startRegistration,touchmove:moveRegistration,mousemove:moveRegistration,scroll:scrollRegistration};var emptyResponder={id:null,idPath:null,node:null};var responderListenersMap=new Map();var isEmulatingMouseEvents=false;var trackedTouchCount=0;var currentResponder={id:null,node:null,idPath:null};function changeCurrentResponder(responder){currentResponder=responder;}function getResponderConfig(id){var config=responderListenersMap.get(id);return config!=null?config:emptyObject;}/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */function eventListener(domEvent){var eventType=domEvent.type;var eventTarget=domEvent.target;/**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */ // Flag when browser may produce emulated events\nif(eventType==='touchstart'){isEmulatingMouseEvents=true;}// Remove flag when browser will not produce emulated events\nif(eventType==='touchmove'||trackedTouchCount>1){isEmulatingMouseEvents=false;}// Ignore various events in particular circumstances\nif(// Ignore browser emulated mouse events\neventType==='mousedown'&&isEmulatingMouseEvents||eventType==='mousemove'&&isEmulatingMouseEvents||// Ignore mousemove if a mousedown didn't occur first\neventType==='mousemove'&&trackedTouchCount<1){return;}// Remove flag after emulated events are finished\nif(isEmulatingMouseEvents&&eventType==='mouseup'){if(trackedTouchCount===0){isEmulatingMouseEvents=false;}return;}var isStartEvent=(0,_ResponderEventTypes.isStartish)(eventType)&&(0,_utils.isPrimaryPointerDown)(domEvent);var isMoveEvent=(0,_ResponderEventTypes.isMoveish)(eventType);var isEndEvent=(0,_ResponderEventTypes.isEndish)(eventType);var isScrollEvent=(0,_ResponderEventTypes.isScroll)(eventType);var isSelectionChangeEvent=(0,_ResponderEventTypes.isSelectionChange)(eventType);var responderEvent=(0,_createResponderEvent[\"default\"])(domEvent);/**\n   * Record the state of active pointers\n   */if(isStartEvent||isMoveEvent||isEndEvent){if(domEvent.touches){trackedTouchCount=domEvent.touches.length;}else{if(isStartEvent){trackedTouchCount=1;}else if(isEndEvent){trackedTouchCount=0;}}_ResponderTouchHistoryStore[\"default\"].recordTouchTrack(eventType,responderEvent.nativeEvent);}/**\n   * Responder System logic\n   */var eventPaths=(0,_utils.getResponderPaths)(domEvent);var wasNegotiated=false;var wantsResponder;// If an event occured that might change the current responder...\nif(isStartEvent||isMoveEvent||isScrollEvent&&trackedTouchCount>0){// If there is already a responder, prune the event paths to the lowest common ancestor\n// of the existing responder and deepest target of the event.\nvar currentResponderIdPath=currentResponder.idPath;var eventIdPath=eventPaths.idPath;if(currentResponderIdPath!=null&&eventIdPath!=null){var lowestCommonAncestor=(0,_utils.getLowestCommonAncestor)(currentResponderIdPath,eventIdPath);if(lowestCommonAncestor!=null){var indexOfLowestCommonAncestor=eventIdPath.indexOf(lowestCommonAncestor);// Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\nvar index=indexOfLowestCommonAncestor+(lowestCommonAncestor===currentResponder.id?1:0);eventPaths={idPath:eventIdPath.slice(index),nodePath:eventPaths.nodePath.slice(index)};}else{eventPaths=null;}}if(eventPaths!=null){// If a node wants to become the responder, attempt to transfer.\nwantsResponder=findWantsResponder(eventPaths,domEvent,responderEvent);if(wantsResponder!=null){// Sets responder if none exists, or negotates with existing responder.\nattemptTransfer(responderEvent,wantsResponder);wasNegotiated=true;}}}// If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\nif(currentResponder.id!=null&&currentResponder.node!=null){var _currentResponder=currentResponder,id=_currentResponder.id,node=_currentResponder.node;var _getResponderConfig=getResponderConfig(id),onResponderStart=_getResponderConfig.onResponderStart,onResponderMove=_getResponderConfig.onResponderMove,onResponderEnd=_getResponderConfig.onResponderEnd,onResponderRelease=_getResponderConfig.onResponderRelease,onResponderTerminate=_getResponderConfig.onResponderTerminate,onResponderTerminationRequest=_getResponderConfig.onResponderTerminationRequest;responderEvent.bubbles=false;responderEvent.cancelable=false;responderEvent.currentTarget=node;// Start\nif(isStartEvent){if(onResponderStart!=null){responderEvent.dispatchConfig.registrationName='onResponderStart';onResponderStart(responderEvent);}}// Move\nelse if(isMoveEvent){if(onResponderMove!=null){responderEvent.dispatchConfig.registrationName='onResponderMove';onResponderMove(responderEvent);}}else{var isTerminateEvent=(0,_ResponderEventTypes.isCancelish)(eventType)||// native context menu\neventType==='contextmenu'||// window blur\neventType==='blur'&&eventTarget===window||// responder (or ancestors) blur\neventType==='blur'&&eventTarget.contains(node)&&domEvent.relatedTarget!==node||// native scroll without using a pointer\nisScrollEvent&&trackedTouchCount===0||// native scroll on node that is parent of the responder (allow siblings to scroll)\nisScrollEvent&&eventTarget.contains(node)&&eventTarget!==node||// native select/selectionchange on node\nisSelectionChangeEvent&&(0,_utils.hasValidSelection)(domEvent);var isReleaseEvent=isEndEvent&&!isTerminateEvent&&!(0,_utils.hasTargetTouches)(node,domEvent.touches);// End\nif(isEndEvent){if(onResponderEnd!=null){responderEvent.dispatchConfig.registrationName='onResponderEnd';onResponderEnd(responderEvent);}}// Release\nif(isReleaseEvent){if(onResponderRelease!=null){responderEvent.dispatchConfig.registrationName='onResponderRelease';onResponderRelease(responderEvent);}changeCurrentResponder(emptyResponder);}// Terminate\nif(isTerminateEvent){var shouldTerminate=true;// Responders can still avoid termination but only for these events.\nif(eventType==='contextmenu'||eventType==='scroll'||eventType==='selectionchange'){// Only call this function is it wasn't already called during negotiation.\nif(wasNegotiated){shouldTerminate=false;}else if(onResponderTerminationRequest!=null){responderEvent.dispatchConfig.registrationName='onResponderTerminationRequest';if(onResponderTerminationRequest(responderEvent)===false){shouldTerminate=false;}}}if(shouldTerminate){if(onResponderTerminate!=null){responderEvent.dispatchConfig.registrationName='onResponderTerminate';onResponderTerminate(responderEvent);}changeCurrentResponder(emptyResponder);isEmulatingMouseEvents=false;trackedTouchCount=0;}}}}}/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */function findWantsResponder(eventPaths,domEvent,responderEvent){var shouldSetCallbacks=shouldSetResponderEvents[domEvent.type];// for Flow\nif(shouldSetCallbacks!=null){var idPath=eventPaths.idPath,nodePath=eventPaths.nodePath;var shouldSetCallbackCaptureName=shouldSetCallbacks[0];var shouldSetCallbackBubbleName=shouldSetCallbacks[1];var bubbles=shouldSetCallbacks[2].bubbles;var check=function check(id,node,callbackName){var config=getResponderConfig(id);var shouldSetCallback=config[callbackName];if(shouldSetCallback!=null){responderEvent.currentTarget=node;if(shouldSetCallback(responderEvent)===true){// Start the path from the potential responder\nvar prunedIdPath=idPath.slice(idPath.indexOf(id));return{id:id,node:node,idPath:prunedIdPath};}}};// capture\nfor(var i=idPath.length-1;i>=0;i--){var id=idPath[i];var node=nodePath[i];var result=check(id,node,shouldSetCallbackCaptureName);if(result!=null){return result;}if(responderEvent.isPropagationStopped()===true){return;}}// bubble\nif(bubbles){for(var _i=0;_i<idPath.length;_i++){var _id=idPath[_i];var _node=nodePath[_i];var _result=check(_id,_node,shouldSetCallbackBubbleName);if(_result!=null){return _result;}if(responderEvent.isPropagationStopped()===true){return;}}}else{var _id2=idPath[0];var _node2=nodePath[0];var target=domEvent.target;if(target===_node2){return check(_id2,_node2,shouldSetCallbackBubbleName);}}}}/**\n * Attempt to transfer the responder.\n */function attemptTransfer(responderEvent,wantsResponder){var _currentResponder2=currentResponder,currentId=_currentResponder2.id,currentNode=_currentResponder2.node;var id=wantsResponder.id,node=wantsResponder.node;var _getResponderConfig2=getResponderConfig(id),onResponderGrant=_getResponderConfig2.onResponderGrant,onResponderReject=_getResponderConfig2.onResponderReject;responderEvent.bubbles=false;responderEvent.cancelable=false;responderEvent.currentTarget=node;// Set responder\nif(currentId==null){if(onResponderGrant!=null){responderEvent.currentTarget=node;responderEvent.dispatchConfig.registrationName='onResponderGrant';onResponderGrant(responderEvent);}changeCurrentResponder(wantsResponder);}// Negotiate with current responder\nelse{var _getResponderConfig3=getResponderConfig(currentId),onResponderTerminate=_getResponderConfig3.onResponderTerminate,onResponderTerminationRequest=_getResponderConfig3.onResponderTerminationRequest;var allowTransfer=true;if(onResponderTerminationRequest!=null){responderEvent.currentTarget=currentNode;responderEvent.dispatchConfig.registrationName='onResponderTerminationRequest';if(onResponderTerminationRequest(responderEvent)===false){allowTransfer=false;}}if(allowTransfer){// Terminate existing responder\nif(onResponderTerminate!=null){responderEvent.currentTarget=currentNode;responderEvent.dispatchConfig.registrationName='onResponderTerminate';onResponderTerminate(responderEvent);}// Grant next responder\nif(onResponderGrant!=null){responderEvent.currentTarget=node;responderEvent.dispatchConfig.registrationName='onResponderGrant';onResponderGrant(responderEvent);}changeCurrentResponder(wantsResponder);}else{// Reject responder request\nif(onResponderReject!=null){responderEvent.currentTarget=node;responderEvent.dispatchConfig.registrationName='onResponderReject';onResponderReject(responderEvent);}}}}/* ------------ PUBLIC API ------------ */ /**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */var documentEventsCapturePhase=['blur','scroll'];var documentEventsBubblePhase=[// mouse\n'mousedown','mousemove','mouseup','dragstart',// touch\n'touchstart','touchmove','touchend','touchcancel',// other\n'contextmenu','select','selectionchange'];function attachListeners(){if(_ExecutionEnvironment.canUseDOM&&window.__reactResponderSystemActive==null){window.addEventListener('blur',eventListener);documentEventsBubblePhase.forEach(function(eventType){document.addEventListener(eventType,eventListener);});documentEventsCapturePhase.forEach(function(eventType){document.addEventListener(eventType,eventListener,true);});window.__reactResponderSystemActive=true;}}/**\n * Register a node with the ResponderSystem.\n */function addNode(id,node,config){(0,_utils.setResponderId)(node,id);responderListenersMap.set(id,config);}/**\n * Unregister a node with the ResponderSystem.\n */function removeNode(id){if(currentResponder.id===id){terminateResponder();}if(responderListenersMap.has(id)){responderListenersMap[\"delete\"](id);}}/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */function terminateResponder(){var _currentResponder3=currentResponder,id=_currentResponder3.id,node=_currentResponder3.node;if(id!=null&&node!=null){var _getResponderConfig4=getResponderConfig(id),onResponderTerminate=_getResponderConfig4.onResponderTerminate;if(onResponderTerminate!=null){var event=(0,_createResponderEvent[\"default\"])({});event.currentTarget=node;onResponderTerminate(event);}changeCurrentResponder(emptyResponder);}isEmulatingMouseEvents=false;trackedTouchCount=0;}/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */function getResponderNode(){return currentResponder.node;}","map":{"version":3,"names":["exports","__esModule","attachListeners","addNode","removeNode","terminateResponder","getResponderNode","_ExecutionEnvironment","require","_createResponderEvent","_interopRequireDefault","_ResponderEventTypes","_utils","_ResponderTouchHistoryStore","obj","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","Map","isEmulatingMouseEvents","trackedTouchCount","currentResponder","changeCurrentResponder","responder","getResponderConfig","config","get","eventListener","domEvent","eventType","type","eventTarget","target","isStartEvent","isStartish","isPrimaryPointerDown","isMoveEvent","isMoveish","isEndEvent","isEndish","isScrollEvent","isScroll","isSelectionChangeEvent","isSelectionChange","responderEvent","touches","length","recordTouchTrack","nativeEvent","eventPaths","getResponderPaths","wasNegotiated","wantsResponder","currentResponderIdPath","eventIdPath","lowestCommonAncestor","getLowestCommonAncestor","indexOfLowestCommonAncestor","indexOf","index","slice","nodePath","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","cancelable","currentTarget","dispatchConfig","registrationName","isTerminateEvent","isCancelish","window","contains","relatedTarget","hasValidSelection","isReleaseEvent","hasTargetTouches","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","callbackName","shouldSetCallback","prunedIdPath","i","result","isPropagationStopped","_i","_id","_node","_result","_id2","_node2","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","canUseDOM","__reactResponderSystemActive","addEventListener","forEach","document","setResponderId","set","has","_currentResponder3","_getResponderConfig4","event"],"sources":["/Users/fernandorojo/Developer/messing/rea-tree/node_modules/react-native-web/dist/cjs/modules/useResponderEvents/ResponderSystem.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.attachListeners = attachListeners;\nexports.addNode = addNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\nexports.getResponderNode = getResponderNode;\n\nvar _ExecutionEnvironment = require(\"fbjs/lib/ExecutionEnvironment\");\n\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\nvar _utils = require(\"./utils\");\n\nvar _ResponderTouchHistoryStore = _interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\nvar emptyObject = {};\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n  // Flag when browser may produce emulated events\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  } // Remove flag when browser will not produce emulated events\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  } // Ignore various events in particular circumstances\n\n\n  if ( // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  } // Remove flag after emulated events are finished\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent.default)(domEvent);\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    _ResponderTouchHistoryStore.default.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  /**\n   * Responder System logic\n   */\n\n\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder; // If an event occured that might change the current responder...\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node; // Start\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        responderEvent.dispatchConfig.registrationName = 'onResponderStart';\n        onResponderStart(responderEvent);\n      }\n    } // Move\n    else if (isMoveEvent) {\n        if (onResponderMove != null) {\n          responderEvent.dispatchConfig.registrationName = 'onResponderMove';\n          onResponderMove(responderEvent);\n        }\n      } else {\n        var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || // native context menu\n        eventType === 'contextmenu' || // window blur\n        eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur\n        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer\n        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)\n        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node\n        isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n        var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches); // End\n\n        if (isEndEvent) {\n          if (onResponderEnd != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderEnd';\n            onResponderEnd(responderEvent);\n          }\n        } // Release\n\n\n        if (isReleaseEvent) {\n          if (onResponderRelease != null) {\n            responderEvent.dispatchConfig.registrationName = 'onResponderRelease';\n            onResponderRelease(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n        } // Terminate\n\n\n        if (isTerminateEvent) {\n          var shouldTerminate = true; // Responders can still avoid termination but only for these events.\n\n          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n            // Only call this function is it wasn't already called during negotiation.\n            if (wasNegotiated) {\n              shouldTerminate = false;\n            } else if (onResponderTerminationRequest != null) {\n              responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n              if (onResponderTerminationRequest(responderEvent) === false) {\n                shouldTerminate = false;\n              }\n            }\n          }\n\n          if (shouldTerminate) {\n            if (onResponderTerminate != null) {\n              responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n              onResponderTerminate(responderEvent);\n            }\n\n            changeCurrentResponder(emptyResponder);\n            isEmulatingMouseEvents = false;\n            trackedTouchCount = 0;\n          }\n        }\n      }\n  }\n}\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        responderEvent.currentTarget = node;\n\n        if (shouldSetCallback(responderEvent) === true) {\n          // Start the path from the potential responder\n          var prunedIdPath = idPath.slice(idPath.indexOf(id));\n          return {\n            id: id,\n            node: node,\n            idPath: prunedIdPath\n          };\n        }\n      }\n    }; // capture\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    } // bubble\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n/**\n * Attempt to transfer the responder.\n */\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node; // Set responder\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } // Negotiate with current responder\n  else {\n      var _getResponderConfig3 = getResponderConfig(currentId),\n          onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n          onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n      var allowTransfer = true;\n\n      if (onResponderTerminationRequest != null) {\n        responderEvent.currentTarget = currentNode;\n        responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';\n\n        if (onResponderTerminationRequest(responderEvent) === false) {\n          allowTransfer = false;\n        }\n      }\n\n      if (allowTransfer) {\n        // Terminate existing responder\n        if (onResponderTerminate != null) {\n          responderEvent.currentTarget = currentNode;\n          responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';\n          onResponderTerminate(responderEvent);\n        } // Grant next responder\n\n\n        if (onResponderGrant != null) {\n          responderEvent.currentTarget = node;\n          responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n          onResponderGrant(responderEvent);\n        }\n\n        changeCurrentResponder(wantsResponder);\n      } else {\n        // Reject responder request\n        if (onResponderReject != null) {\n          responderEvent.currentTarget = node;\n          responderEvent.dispatchConfig.registrationName = 'onResponderReject';\n          onResponderReject(responderEvent);\n        }\n      }\n    }\n}\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel', // other\n'contextmenu', 'select', 'selectionchange'];\n\nfunction attachListeners() {\n  if (_ExecutionEnvironment.canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n/**\n * Register a node with the ResponderSystem.\n */\n\n\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\n/**\n * Unregister a node with the ResponderSystem.\n */\n\n\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\n\n\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent.default)({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\n\n\nfunction getResponderNode() {\n  return currentResponder.node;\n}"],"mappings":"AAAA,aAEAA,OAAO,CAACC,UAAR,CAAqB,IAArB,CACAD,OAAO,CAACE,eAAR,CAA0BA,eAA1B,CACAF,OAAO,CAACG,OAAR,CAAkBA,OAAlB,CACAH,OAAO,CAACI,UAAR,CAAqBA,UAArB,CACAJ,OAAO,CAACK,kBAAR,CAA6BA,kBAA7B,CACAL,OAAO,CAACM,gBAAR,CAA2BA,gBAA3B,CAEA,GAAIC,CAAAA,qBAAqB,CAAGC,OAAO,CAAC,+BAAD,CAAnC,CAEA,GAAIC,CAAAA,qBAAqB,CAAGC,sBAAsB,CAACF,OAAO,CAAC,wBAAD,CAAR,CAAlD,CAEA,GAAIG,CAAAA,oBAAoB,CAAGH,OAAO,CAAC,uBAAD,CAAlC,CAEA,GAAII,CAAAA,MAAM,CAAGJ,OAAO,CAAC,SAAD,CAApB,CAEA,GAAIK,CAAAA,2BAA2B,CAAGH,sBAAsB,CAACF,OAAO,CAAC,8BAAD,CAAR,CAAxD,CAEA,QAASE,CAAAA,sBAAT,CAAgCI,GAAhC,CAAqC,CAAE,MAAOA,CAAAA,GAAG,EAAIA,GAAG,CAACb,UAAX,CAAwBa,GAAxB,CAA8B,CAAE,UAASA,GAAX,CAArC,CAAwD,CAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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"},"metadata":{},"sourceType":"script"}